<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F02%2F27%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[最大团[搜索剪枝]]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%9C%80%E5%A4%A7%E5%9B%A2-%E6%90%9C%E7%B4%A2%E5%89%AA%E6%9E%9D%2F</url>
    <content type="text"><![CDATA[方法这里的图都是指无向图。 给定一个图 $G = (V, E)$，如果有一个点集 $V’ \subseteq V$， 满足对于任意点对 $u, v \in V’$ 都有边 $(u, v) \in E$, 则成 $V’$ 对于 $G$ 的诱导子图 $G’$ 是 $G$ 的一个完全子图。 （诱导子图： 子图 $G’ = (V’, E’)$ 满足 $V’ \subseteq V$，$E’ = {(u, v)|u,v \in V’, (u, v) \in E}$） 简单来说，团就是 $G$ 的一个完全子图。 极大团： 如果一个团不被任意一个团所包含（即它不是任意一个团的真子集），则称这个团为 $G$ 的一个极大团。 最大团：极大团中点数最多的那个团。 最大独立集：一个无向图的独立集大小即为它补图（边的存在性取反）的最大团大小（其点集也相同） 因为求最大团是 $NP$ 问题，但是在 $n \leqslant 100$ 搜索+剪枝可以跑的非常快 (0.01s 以内) 一、先想到一个最简单的 $dfs$ 最开始的点集 $S = { i | 1 \leqslant i \leqslant n }$ 1、从 $S$ 中取出来一个点 $x$，把 $S$ 中所有 $x$ 能访问到的点 放入集合 $S_1$，再将这个集合 $S_1$ 作为新的 $S$。 2、如果 $S$ 还有元素，重复操作 1，否则停止 $dfs$，这时候就找到了 $G$ 的一个完全子图。直到找到所有的完全子图。 二、试图优化 $dfs$ 我们让这个 $S$ 为当前枚举到的点和它后面所有的点。 这样，当某个 S 集合为空时，$dfs$ 结束，得到一个只用后面几个点构成的完全子图，并用它去更新只用后面几个点构成的最大团。退出当前 DFS，返回上层 DFS，接着找下一个完全子图，直到找完所有的完全子图。 三、试图剪枝 记当前取出来的点的个数为 $num$ 如果我们现在取出了 $S$ 中的一个元素 $x$，要将 $S$ 中 $x$ 后面与 $x$ 相连的点加入 $S_1$ 的时候，考虑： 剪枝1： 如果 $num + S$ 中剩下的元素个数 $\leqslant ans$ ， 剪枝 按照我们 $dfs$ 的方式，当选中编号为 $x$ 的点时，一定知道了 $[x + 1, n]$，$[x + 2, n]$， $\cdots$， $[n, n]$ 这些区间的点能构成的最大团的大小。记区间 $[x + 1, n]$ 的最大团的大小为 $mxsize[x + 1]$ 剪枝2：如果 $num + mxsize[x] \leqslant ans$ ，剪枝 剪枝3： 如果 $dfs$ 到了最底层，并且能够更新答案，就不要在 $dfs$ 了，结束 因为如果我们继续枚举 $dfs$，点的编号变大了，可用点变少（可用的点在一开始 $dfs$ 初始化的时候就确定了，随着不断的加深 $dfs$ 的层数，可用的点在不断的减少） 剪枝后真点跑的飞快 例题HDU 1530 Maximum CliqueVjudge-Link HDU-Link 模板题 upd 2.25 : 以前用的是vector，常数巨大，跑的巨慢，于是换成了数组 同一组数据：数组 3s，vector 45s，vector+O2 4.5s 1234567891011121314151617181920212223242526272829303132333435int best, G[N][N], mxsize[N], arr[N][N];bool dfs(const int sz, const int num)&#123; int *a = arr[num]; if (!sz) return best &lt; num ? best = num, true : false; for (int i = 1; i &lt;= sz; i++) &#123; if (num + sz - i + 1 &lt;= best || num + mxsize[a[i]] &lt;= best) return false; int tot = 0; for (int j = i + 1; j &lt;= sz; j++) if (G[a[i]][a[j]]) arr[num + 1][++tot] = a[j]; if (dfs(tot, num + 1)) return true; &#125; return false;&#125;void MC()&#123; best = 0; memset(mxsize, 0, sizeof(int[n + 1])); for (int i = n; i; i--) &#123; int tot = 0; for (int j = i + 1; j &lt;= n; j++) if (G[i][j]) arr[1][++tot] = j; dfs(tot, 1); mxsize[i] = best; &#125;&#125; HDU 3585Vjudge-Link HDU-Link 要求找出来 $k$ 个点，使得这 $k$ 个点中距离最远的两个点的距离最大。 二分答案， 根据 $mid$ 重新建图，判断条件是当前这个图的最大团大小是否大于等于 $k$ 参考资料https://www.cnblogs.com/zhj5chengfeng/p/3224092.html]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>最大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector[计算几何]]]></title>
    <url>%2F2019%2F02%2F23%2FVector-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[话说我怎么总有一种抄了一段书的感觉……（本人使用，纯粹怕忘） 不知道为什么博客上 $\degree$ 会变成这样…… 记了一些计算几何里面会用到的一些很基础的东西，代码是抄的 lrj 大大的 定义12345678910111213141516const double eps = 1e-10;struct Point&#123; double x, y; Point(const double _x = 0, const double _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;typedef Point Vector; // 在实现上 Vector 只是 Point 的别名// 向量 + 向量 = 向量， 点 + 向量 = 点inline Vector operator + (const Vector &amp;A, const Vector &amp;B) &#123;return Vector(A.x + B.x, A.y + B.y);&#125;// 点- 点 = 向量inline Vector operator - (const Point &amp;A, const Point &amp;B) &#123;return Vector(A.x - B.x, A.y - B.y);&#125;// 向量 × 数值 = 向量inline Vector operator * (const Vector &amp;A, const double p) &#123;return Vector(A.x * p, A.y * p);&#125;// 向量 / 数值 = 向量inline Vector operator / (const Vector &amp;A, const double p) &#123;return Vector(A.x / p, A.y / p);&#125; 以及位置关系的比较函数 (不知道有啥用.jpg)12345678inline bool operator &lt; (const Point &amp;A, const Point &amp;B)&#123; return A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y);&#125;inline bool operator == (const Point &amp;A, const Point &amp;B)&#123; return fabs(A.x - B.x) &lt; eps &amp;&amp; fabs(A.y - B.y) &lt; eps;&#125; 基本运算点积两个向量 $v$ 和 $w$ 的点积等于二者长度的乘积再乘上它们夹角的余弦。 因为余弦函数是偶函数，因此点积满足交换律。当夹角 $&gt; 90$ 度 时点积为负，如果两向量垂直，则点积为 $0$。 在坐标系下，两个向量 $OA$ 和 $OB$ 的点积等于 $x_A x_B + y_A + y_B$ 1inline double Dot(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.x + A.y * B.y;&#125; 然后还可以偷个懒用点积算模长 （其实就是 $\sqrt{x^2 + y^2}$） 1inline double Length(const Vector &amp;A) &#123;return sqrt(Dot(A, A));&#125; 然后再利用 $\operatorname{acos}$ 函数求两向量的夹角大小，其中 $\operatorname{acos}$ 得到的是弧度制 1inline double Angle(const Vector &amp;A, const Vector &amp;B) &#123;return acos(Dot(A, B) / Length(A) / Length(B));&#125; 叉积两个向量 $v$ 和 $w$ 的叉积等于 $v$ 和 $w$ 组成的三角形的有向面积的两倍。 叉积不满足交换律，但是有 $cross(v, w) = -cross(w, v)$ 在坐标系下，两个向量 $OA$ 和 $OB$ 的叉积等于 $x_A y_B - y_A x_B$ 1inline double Cross(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.y - A.y * B.x;&#125; 有了叉积，自然可以算三角形的面积了，别忘了 $S_{ABC} = fabs(Area2(A, B, C)) / 2$ 1inline double Area2(const Point &amp;A, const Point &amp;B, const Point &amp;C) &#123;return Cross(B - A, C - A);&#125; 向量旋转向量可以绕起点旋转，公式为 $x’ = x \cos a - y \sin a$ ，$y’ = x \sin a - y \cos a$，其中 $a$ 为逆时针旋转的角（弧度） 1234inline Vector Rotate(const Vector &amp;A, double rad)&#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125; 特殊情况，计算向量的单位法线，即左转 $90$ 度 以后把长度归一化123456// 调用前请确保 A 不是零向量Vector Normal(const Vector &amp;A)&#123; double L = Length(A); return Vector(-A.y / L, A.x / L);&#125; 点和直线直线的参数表示直线可以用直线上一点 $P_0$ 和方向向量 $v$ 表示($v$ 的大小没有用)，直线上所有点 $P$ 满足 $P = P_0 + tv$ ，其中 $t$ 称为参数。例如，如果已知直线上的两个不同点 $A$ 和 $B$，则方向向量为 $B - A$，所以参数方程为 $A + (B - A)t$ 参数方程最方便的地方在于直线、射线和线段的方程形式是一样的，区别仅仅在于参数的范围，故很多对于直线适用的公式对于射线、线段依旧适用。 直线交点设直线分别为 $P + tv$ 和 $Q + tw$ ，设向量 $u = P - Q$，交点在直线一的参数为 $t_1$，交点在直线二的参数为 $t_2$，，解方程得$$t_1 = \frac{cross(w, u)}{cross(v, w)} \ \ \ \ t_2 = \frac{cross(v, u)}{cross(v, w)}$$ 调用前请确保两条直线有唯一交点，当且仅当 $cross(v, w) \neq 0$ 123456inline Point GetLineIntersection(const Point &amp;P, const Vector &amp;v, const Point &amp;Q, const Vector &amp;w)&#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125; 点到直线距离利用叉积，平行四边形面积除以底即可 1234inline double DistanceToLink(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; return fabs(Cross(B - A, P - A)) / Length(B - A);&#125; 当然如果有了解析式（直线方程的一般式 $Ax + By + C = 0$ )，也可以利用高中数学的公式计算 $$d = \frac{\mid Ax_p + By_p + C \mid}{\sqrt{A^2 + B^2}}$$ 点到线段距离设投影点为 $Q$，分类讨论 $Q$ 在线段 $AB$ 上，则所求距离就是 $P$ 点与直线 $AB$ 的距离 $Q$ 在射线 $BA$ 上，则所求距离为 $dis(P, A)$ $Q$ 在射线 $AB$ 上，则所求距离为 $dis(P, B)$ 判断 $Q$ 的位置可以用点积进行（利用权值的正负） 12345678inline double DistanceToSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; if (A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if (Dot(v1, v2) &lt; 0) return Length(v2); // ∠PAB &gt; 90°，ans = dis(A, P) else if (Dot(v1, v3)) return Length(v3); // ∠PBA &gt; 90°，ans = dis(B, P) else return fabs(Cross(v1, v2)) / Length(v1); // 投影点在线段AB上&#125; 点在直线上的投影把直线 $AB$ 写成参数式 $A+tv$ 其中（向量 $v$ 是 $B - A$），并且设点 $Q$ 的参数为 $t_0$ ，那么 $Q = A + t_0v$ 。 根据 $PQ$ 垂直于 $Q$，两个向量的点积应该为 $0$，因此 $Dot(v, P- (A + t_0v)) = 0$ 根据分配率，有 $Dot(v, P - A) - t_0 \times Dot(v, v) = 0$ $t_0 = Dot(v, P - A) / Dot(v, v)$ 就可以求得 $t_0$ 了。 12345inline Point GetLineProjection(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125; 判断两条线段是否相交不允许在端点处相交：定义“规范相交”为：两线段恰好有一个公共点，并且不在任何一条线段的端点。即 。 方法：快速排斥+跨立实验 快速排斥：以 $A_1B_1$，$A_2B_2$ 为对角线的两个矩形相交 跨立实验：以一条线段为标准，另一条线段的两个端点在这条线段两侧(这里的“两侧”是指叉积的符号不同) 123456789inline bool SegmentProperIntersection(const Point &amp;A1, const Point &amp;B1, const Point &amp;A2, const Point &amp;B2)&#123; if (!(min(A1.x, B1.x) &lt;= max(A2.x, B2.x) &amp;&amp; min(A2.x, B2.x) &lt;= max(A1.x, B1.x) &amp;&amp; min(A1.y, B1.y) &lt;= max(A2.y, B2.y) &amp;&amp; min(A2.y, B2.y) &lt;= max(A1.y, A2.y))) return false; // 快速排斥 double c1 = Cross(A2 - A1, B1 - A1); double c2 = Cross(A2 - A1, B2 - A1); double c3 = Cross(B2 - B1, A1 - B1); double c4 = Cross(B2 - B1, A2 - B1); return c1 * c2 &lt; 0 &amp;&amp; c3 * c4 &lt; 0;&#125; 允许在端点处相交分类讨论 如果 $c_1$， $c_2$ 都是 $0$，两线段共线，可能有部分重叠的情况 如果 $c_1$， $c_2$ 都不是 $0$，则只有某个端点在两一条线段上这一种相交方法，为了判断上述情况是否发生，还需要判断一个点是否在一条线段上（不含端点），如下 1234inline bool OnSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; return fabs(Cross(A - P, B - P)) &lt; eps &amp;&amp; Dot(A - P, B - P) &lt; 0;&#125; 也许还会接着补，说不定就咕咕咕了…… 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182namespace PointAndVector&#123; const double eps = 1e-10; struct Point &#123; double x, y; Point(const double _x = 0, const double _y = 0) : x(_x), y(_y) &#123;&#125; &#125;; typedef Point Vector; inline Vector operator + (const Vector &amp;A, const Vector &amp;B) &#123;return Vector(A.x + B.x, A.y + B.y);&#125; inline Vector operator - (const Vector &amp;A, const Vector &amp;B) &#123;return Vector(A.x - B.x, A.y - B.y);&#125; inline Vector operator * (const Vector &amp;A, const double p) &#123;return Vector(A.x * p, A.y * p);&#125; inline Vector operator / (const Vector &amp;A, const double p) &#123;return Vector(A.x / p, A.y / p);&#125; inline bool operator &lt; (const Point &amp;A, const Point &amp;B) &#123; return A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y); &#125; inline bool operator == (const Point &amp;A, const Point &amp;B) &#123; return fabs(A.x - B.x) &lt; eps &amp;&amp; fabs(A.y - B.y) &lt; eps; &#125; inline double Dot(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.x + A.y * B.y;&#125; inline double Length(const Vector &amp;A) &#123;return sqrt(Dot(A, A));&#125; inline double Angle(const Vector &amp;A, const Vector &amp;B) &#123;return acos(Dot(A, B) / Length(A) / Length(B));&#125; inline double Cross(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.y - A.y * B.x;&#125; inline double Area2(const Point &amp;A, const Point &amp;B, const Point &amp;C) &#123;return Cross(B - A, C - A);&#125; inline Vector Rotate(const Vector &amp;A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad)); &#125; inline Point GetLineIntersection(const Point &amp;P, const Vector &amp;v, const Point &amp;Q, const Vector &amp;w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t; &#125; inline double DistanceToLink(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; return fabs(Cross(B - A, P - A)) / Length(B - A); &#125; inline double DistanceToSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; if (A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if (Dot(v1, v2) &lt; 0) return Length(v2); else if (Dot(v1, v3)) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1); &#125; inline Point GetLineProjection(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v)); &#125; inline bool SegmentProperIntersection(const Point &amp;A1, const Point &amp;B1, const Point &amp;A2, const Point &amp;B2) &#123; if (!(min(A1.x, B1.x) &lt;= max(A2.x, B2.x) &amp;&amp; min(A2.x, B2.x) &lt;= max(A1.x, B1.x) &amp;&amp; min(A1.y, B1.y) &lt;= max(A2.y, B2.y) &amp;&amp; min(A2.y, B2.y) &lt;= max(A1.y, A2.y))) return false; double c1 = Cross(A2 - A1, B1 - A1); double c2 = Cross(A2 - A1, B2 - A1); double c3 = Cross(B2 - B1, A1 - B1); double c4 = Cross(B2 - B1, A2 - B1); return c1 * c2 &lt; 0 &amp;&amp; c3 * c4 &lt; 0; &#125; inline bool OnSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; return fabs(Cross(A - P, B - P)) &lt; eps &amp;&amp; Dot(A - P, B - P) &lt; 0; &#125;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4652[NOI2016] 循环之美 [杜教筛]]]></title>
    <url>%2F2019%2F02%2F22%2Fbzoj4652%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E-%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[题面bzoj4652luogu1587 给定正整数 $n$, $m$, $k$,求 $\frac{y}{x}$ 在 $k$ 进制下为纯循环小数的不同的的值的个数,其中 $x$, $y$ 为正整数且 $x \leqslant n,y \leqslant m$。 其中 $n, m \leqslant 10^9 ,k \leqslant 2000$。 纯循环：循环节从小数点后开始 分析首先要是既约分数，故有 $\gcd(x,y)=1$ 它是一个 $k$ 进制下纯循环小数的条件是存在 $x \times k^{\alpha} \equiv x \mod y$，即 $\gcd(k, y) = 1$ 证明： 非常感谢给我证了这个的兔子神仙！！！ 因为 $x \neq 0$ ，即要证 $k^a \equiv 1 \mod y$ 充分性: 根据鸽巢原理(咕巢原理)可得一定存在 $i$， $j$ ($i &lt; j$) 使得 $k^i \equiv k^j \mod y$ 因为 $(k,y)=1$，除过去可得 $k^{j-i} \equiv 1 \mod y$。 必要性: 首先有:当 $(a,b)=1$ 时，$(a^x,b)=1$ $k^a \equiv 1 \mod y$ 即 $k^a + b \times y = 1$，根据裴蜀定理可得$(k^a,y)=1$ 故可得只有当 $(k,y)=1$ 才有 $k^a \equiv 1 \mod y$ 裴蜀定理(推论): $a$, $b$ 互质的充要条件是存在整数$x$, $y$ 使 $ax+by=1$. 所以答案为$$\sum_{x=1}^n \sum_{y=1}^n \epsilon(\gcd(x, y)) \epsilon(\gcd(y, k))$$ 然后就是愉悦的推式子环节 记 $h(x) = [(x,k)=1]$, $S_h$表示 $h$ 的前缀和, 记 $f(x) = [(d,k)=1] \mu(d)$$$= \sum_{d=1}^n f(d) \lfloor\frac{n}{d}\rfloor S(\lfloor\frac{m}{d}\rfloor)\$$后面两个数论分块后就要求 $f$ 的前缀和,因为 $f = \mu \cdot h$, 要杜教筛还要找一个函数 $g$, 按照套路可得 $g=h$ 因为 $h(1)=1$, 故 $\sum_{i=1}^n(f * h)(n) = [n \geqslant 1]$ 对于 $S_h$ , 有 $S_h(n) = \lfloor\frac{n}{k}\rfloor \varphi(k) + h(n \% k) = \lfloor\frac{n}{k}\rfloor h(k) + h(n \% k)$ 因为不知道为什么那两个公式炸了（本地看都好好的），懒得找原因了于是用图片代替 完结撒花~ 代码因为要有 $n$ 和 $m$ 的两个数论分块后的结果(要分开) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int K = 2010; const int N = 1000000; const int M = 1000; int n, m, k, S[K + 5], Pre[N + 5], Sum[2][M + 5]; int gcd(const int a, const int b) &#123; return !b ? a : gcd(b, a % b); &#125; void init() &#123; static int cnt, prime[N + 5], vis[N + 5], mu[N + 5]; mu[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!vis[i]) prime[++cnt] = i, mu[i] = -1; for (int j = 1, t; j &lt;= cnt &amp;&amp; (t = i * prime[j]) &lt;= N; j++) &#123; vis[t] = 1; if (!(i % prime[j])) &#123;mu[t] = 0;break;&#125; mu[t] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= k; i++) &#123; int t = (gcd(k, i) == 1); S[i] = S[i - 1] + t; Pre[i] = Pre[i - 1] + mu[i] * t; &#125; for (int i = k + 1; i &lt;= N; i++) Pre[i] = Pre[i - 1] + mu[i] * (gcd(i, k) == 1); &#125; inline int calc(const int x) &#123; return (x / k) * S[k] + S[x % k]; &#125; int GetSum(const int x, const int type) &#123; static bool vis[2][M + 5]; if (x &lt;= N) return Pre[x]; int t = (!type ? n : m) / x; if (!vis[type][t]) &#123; int res = 1; for (int l = 2, r; l &lt;= x; l = r + 1) &#123; r = x / (x / l); res -= (calc(r) - calc(l - 1)) * GetSum(x / l, type); &#125; Sum[type][t] = res; vis[type][t] = 1; &#125; return Sum[type][t]; &#125; void work() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); init(); GetSum(n, 0), GetSum(m, 1); ll ans = 0; int last = 0, now, lim = min(n, m); for (int l = 1, r; l &lt;= lim; l = r + 1) &#123; int t1 = n / (n / l), t2 = m / (m / l); now = GetSum((r = min(t1, t2)), t1 &gt; t2); ans = ans + (ll)(now - last) * (n / l) * calc(m / l); last = now; &#125; printf("%lld\n", ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4816 [SDOI2017]数字表格 [莫比乌斯反演]]]></title>
    <url>%2F2019%2F01%2F27%2Fbzoj4816%C3%8A%C3%BD%C3%97%C3%96%C2%B1%C3%AD%C2%B8%C3%B1%2F</url>
    <content type="text"><![CDATA[题目Luogu 3704Bzoj 4816 求$$\prod_{i=1}^n \prod_{j=1}^m f[gcd(i, j)]$$其中 $f[i]$ 为 $Fibonacci$ 数列的第 $i$ 项。答案对 $10^9 + 7$ 取模。 分析首先肯定是要写暴力（要把自己摘出来 - $from \ Tril$），假定 $n \leqslant m$ 把 $Fibonacci$ 数列打出来，记 $times[d]$ 表示满足 $[gcd(i, j)] = d$ 的 $(i, j)$ 的对数，然后就有 $$times[d] = \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor - \sum_{i=1}^{n} times[i \times d]$$ 然后就有 $60$ 分了，不想写正解了快溜，复杂度 $O(T n log log n)$ 看到 $gcd$ 就想到莫比乌斯反演，令 $gcd(i, j) = d$ 推式子$$\begin{aligned}&amp; = \prod_{i=1}^n \prod_{j=1}^m \sum_{d=0}^n f[d] \ [gcd(i, j) = d] \&amp; = \prod_{d=1}^n f[d]^{ \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{i=1}^{\lfloor \frac{m}{d} \rfloor} [gcd(i, j) = 1]}\end{aligned}$$ 提出次数，反演 $$\begin{aligned}&amp; \ \ \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{i=1}^{\lfloor \frac{m}{d} \rfloor} [gcd(i, j) = 1] \&amp; = \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{i=1}^{\lfloor \frac{m}{d} \rfloor} \sum_{g|gcd(i,j)} \mu(g) \&amp; = \sum_{g=1}^{\lfloor \frac{n}{d} \rfloor} \mu(g) \lfloor \frac{n}{dg} \rfloor \lfloor \frac{m}{dg} \rfloor\end{aligned}$$ 令 $T = dg$ $$= \mu (\frac{T}{d}) \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$$ $\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$ 可以数论分块了，提出来，带回原式 $$\begin{aligned}&amp;=\prod_{d=1}^n f[d]^{\sum_{g=1}^{\lfloor \frac{n}{d} \rfloor} \mu(g) \lfloor \frac{n}{dg} \rfloor \lfloor \frac{m}{dg} \rfloor} \&amp;=\prod_{T=1}^n \left( \prod_{d|T} f[d]^{\mu(\frac{T}{d})} \right)^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}\end{aligned}$$ 令 $F(T) = \prod_{d|T} f[d]^{\mu(\frac{T}{d})}$ $$=\prod_{T=1}^n F(T)^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}$$ 然后如果可以预处理 $F(T)$，那么直接数论分块就可以了。 预处理可以直接刷表，枚举 $d$ 和 $d$ 的倍数，$O(n log log n)$ 预处理即可。 复杂度应该没有问题吧 代码这个是 $60$ 分的暴力，空格好哇12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1e6 + 10; const int p = 1e9 + 7; const int Phi = 1e9 + 6; int f[N], times[N]; inline int read() &#123; int x = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return x; &#125; #define Mod(x) (x) &gt;= p ? (x) - p : (x) inline ll qpow(ll x, ll tim) &#123; ll ans = 1; for (; tim; tim &gt;&gt;= 1, x = x * x % p) if (tim &amp; 1) ans = ans * x % p; return ans; &#125; void work() &#123; f[0] = 0, f[1] = 1; for (int i = 2; i &lt;= 1000000; i++) f[i] = Mod(f[i - 1] + f[i - 2]); int T = read(); while (T--) &#123; int n = read(), m = read(), mn = min(n, m); memset(times, 0, sizeof(int[mn + 1])); for (int i = mn; i; i--) &#123; times[i] = (ll)(n / i) * (m / i) % Phi; for (int j = i + i; j &lt;= mn; j += i) times[i] = (times[i] - times[j] + Phi) % Phi; &#125; ll ans = 1LL; for (int i = 1; i &lt;= mn; i++) ans = ans * qpow(f[i], times[i])% p; printf("%lld\n", ans); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; Accepted123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1e6; const int p = 1e9 + 7; int f[N + 5], F[N + 5], mu[N + 5]; inline int read() &#123; int x = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return x; &#125; #define Mod(x) (x) &gt;= p ? (x) - p : (x) inline ll qpow(ll x, ll tim) &#123; if (tim &lt; 0) tim += p - 1; ll ans = 1; for (; tim; tim &gt;&gt;= 1, x = x * x % p) if (tim &amp; 1) ans = ans * x % p; return ans; &#125; void get_mu() &#123; static int cnt, prime[N], vis[N + 5]; mu[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!vis[i]) prime[++cnt] = i, mu[i] = -1; for (int j = 1, k; j &lt;= cnt &amp;&amp; (k = i * prime[j]) &lt;= N; j++) &#123; vis[k] = 1; if (i % prime[j] == 0) break; mu[k] = -mu[i]; &#125; &#125; &#125; void init() &#123; f[0] = 0, f[1] = 1; for (int i = 2; i &lt;= N; i++) f[i] = Mod(f[i - 1] + f[i - 2]); get_mu(); static int arr[3]; for (int i = 0; i &lt;= N; i++) F[i] = 1; for (int i = 1; i &lt;= N; i++) &#123; arr[0] = qpow(f[i], -1); arr[2] = f[i]; for (int j = i; j &lt;= N; j += i) if (mu[j / i]) F[j] = (ll)F[j] * arr[mu[j / i] + 1] % p; &#125; for (int i = 2; i &lt;= N; i++) F[i] = (ll)F[i - 1] * F[i] % p; &#125; void work() &#123; init(); int T = read(); while (T--) &#123; int n = read(), m = read(); if(n &gt; m) swap(n, m); ll ans = 1; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ll inv = qpow(F[l - 1], p - 2); ans = ans * qpow(F[r] * inv % p, (ll)(n / l) * (m / l) % (p - 1)) % p; &#125; printf("%lld\n", ans); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4566 [HAOI2016]找相同字符 [SAM]]]></title>
    <url>%2F2019%2F01%2F12%2Fbzoj4566%C3%95%C3%92%C3%8F%C3%A0%C3%8D%C2%AC%C3%97%C3%96%C2%B7%C3%BB%2F</url>
    <content type="text"><![CDATA[写在前面写这篇题解的原因纯粹是 zyt 神仙的方法太麻烦了 题目luogu 3181 bzoj 4566 给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。 $1 \leqslant length \leqslant 200000$ 方法可以直接跳到“简单来说” 对于有多个串的问题，我们可以建广义 $SAM$，但是实际上没有什么必要，可以将每两个串之间用一个奇怪的字符（例如 $’a’+26$）全部连起来，变成一个串，对于这个串建 $SAM$。 然后可以发现，如果这两个串有一个子串相同，那么这个子串在 $SAM$ 上对应的是同一个节点。我们转化一下，如果 $SAM$ 上的一个节点在串 $A$ 中的 $right$ 集合大小为 $a$，在串 $B$ 中的 $right$ 集合大小为 $b$，那么 $a$ ，$b$ 中任意两个配对都是一个合法的情况（即子串相同）。 又因为要求是本质不同的子串，$SAM$ 上每个节点代表了长度在 $[minlen,maxlen]$ 之间的相同的子串，故每个点的贡献还要乘上 $maxlen-minlen+1$。 简单来说，连接串 $A$，$B$ 建在一个 $SAM$ 上，如果用 $tot$ 表示 $SAM$ 的点数， $size[i][0/1]$ 表示 $SAM$ 上节点 $i$ 中包含的串 $A$ 或 $B$ 的 $right$ 集合的大小，$mx[i]$ 表示点 $i$ 的 $maxlen$，那么$$ans=\sum_{i=1}^{tot} size[i][0] \times size[i][1] \times (mx[i] - mx[fa[i]])$$ 代码代码写起来就是 $SAM$ 的基础操作：插入和基数排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=800010; long long ans; namespace SAM &#123; int last=1,tot=1,size[N][2]; struct node &#123; int fa,mx,son[27]; &#125;tr[N]; void insert(const int c,const int id) &#123; int now=++tot,p=last; tr[now].mx=tr[p].mx+1; if(id!=2) size[now][id]++; while(p&amp;&amp;!tr[p].son[c]) tr[p].son[c]=now,p=tr[p].fa; if(!p) tr[now].fa=1; else &#123; int q=tr[p].son[c]; if(tr[q].mx==tr[p].mx+1) tr[now].fa=q; else &#123; int clone=++tot; tr[clone]=tr[q]; tr[clone].mx=tr[p].mx+1; tr[q].fa=tr[now].fa=clone; while(p&amp;&amp;tr[p].son[c]==q) tr[p].son[c]=clone,p=tr[p].fa; &#125; &#125; last=now; &#125; void radix_sort() &#123; static int bask[N],q[N]; for(int i=1;i&lt;=tot;i++) bask[tr[i].mx]++; for(int i=1;i&lt;=tot;i++) bask[i]+=bask[i-1]; for(int i=tot;i;i--) q[bask[tr[i].mx]--]=i; for(int i=tot;i&gt;1;i--) &#123; int now=q[i],f=tr[now].fa; size[f][0]+=size[now][0]; size[f][1]+=size[now][1]; ans+=(long long)size[now][0]*size[now][1]*(tr[now].mx-tr[f].mx); &#125; &#125; &#125; void work() &#123; static char s[N&gt;&gt;1]; scanf("%s",s); int len=strlen(s); for(int i=0;i&lt;len;i++) SAM::insert(s[i]-'a',0); SAM::insert(26,2); scanf("%s",s); len=strlen(s); for(int i=0;i&lt;len;i++) SAM::insert(s[i]-'a',1); SAM::radix_sort(); printf("%lld",ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有上下界的网络流/费用流 学习笔记 [网络流]]]></title>
    <url>%2F2019%2F01%2F10%2F%C3%93%C3%90%C3%89%C3%8F%C3%8F%C3%82%C2%BD%C3%A7%C2%B5%C3%84%C3%8D%C3%B8%C3%82%C3%A7%C3%81%C3%B7%2F</url>
    <content type="text"><![CDATA[安利博客 liu_runda 有上下界的网络流，顺便抄一段话 有上下界的网络流的核心是”调整”,我们通过一个初始的未必可行的流调整出一个可行流,还可以从可行的未必最大/最小的流调整出最大/最小。另一个常用技巧是有源汇的流和无源汇的流(循环流)的转换。除了无源汇可行流的求解,其他有源汇的上下界网络流都要用到这个技巧。 无源汇上下界可行流 （循环流）模型给定一个网络，求一个流，满足每条边的流量都 $min \leqslant flow \leqslant max$ ，并且每个点都满足 总流入量=总流出量（流量守恒） ，没有源汇。 核心思想将一个不满足流量守恒的初始流调整成满足流量守恒的流。 方法如果存在一个可行流，它一定满足每条边的流量都大于等于下界。那么我们可以先令每条边的流量等于它的下界，得到一个初始流，然后建出这个流的残余网络（每条边流量为上下界之差）。初始流不一定满足流量守恒，我们要做的就是通过增加某些边的流量使它流量守恒来得到一个可行流。 我们将之后扩大流量的流叫做附加流，初始流合并附加流就是可行流。那么，为达到流量守恒，一定存在： 如果一个点在初始流中满足流量守恒，那么它在附加流中也满足流量守恒 如果一个点在初始流中的流入量比流出量多 $x$ ，那么它在附加流中流出量比流入量少 $x$ 如果一个点在初始流中的流入量比流出量少 $x$ ，那么它在附加流中流出量比流入量多 $x$ 我们用 $d[i]$ 表示点 $i$ 在初始流中流入量-流出量的值，那么 $d[i]$ 的正负就可以表示以上三种情况。 如果一个点$d[i] &lt; 0$，我们需要给多出的流入量一个出处，需要让附加流中 $i$ 的流入量比流出量少 $-d[i]$，所以建一条从 $i$ 出发的边，流量为 $-d[i]$；如果 $d[i] &gt; 0$，则建一条指向 $i$ 的边，流量为$d[i]$。 虚拟源汇点 $s$，$t$。分类$$\left{\begin{aligned}d[i] &gt; 0 &amp; \ \ \ \ 建 s 指向 i 的边，使附加流中 i 的流出量增加 d[i] \d[i] &lt; 0 &amp; \ \ \ \ 建 i 指向 t 的边，使附加流中 i 的流入量增加 -d[i] \\end{aligned}\right.$$ 为了得到一个可行流，指向 $t$ 的边的总流量上限必须等于从 $s$ 出发的边的总流量上限，因为原图上每条边对两个端点的 $d[i]$ 的贡献一正一负绝对值相同，所以 $\sum_{i=1}^n d[i] = 0$，并且$$ \sum_{d[i]&lt;0} |d[i]| = \sum_{d[i]&gt;0} |d[i]|$$ 除了连接 $s$，$t$ 的边以外，在连上原图中的边，流量为上界-下界。在这个图上，如果我们能够找到一个流满足所有连接 $s$，$t$ 的边都满流，那这个流在原图中边上的流量就是我们要的附加流。这样的流就是我们所建的新图中 $s$ 到 $t$ 的最大流。 存在可行流的条件：$s$ 到 $t$ 的最大流 = $\sum_{d[i]&gt;0} d[i]$ 最后，每条边的流量 = 下界 + 附加流中它的流量 例题ZOJ2314 Reactor Cooling 求是否存在一个无源汇可行流，若存在，输出每条边的流量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=210; const int M=40010; const int inf=0x3f3f3f3f; int n,m,cnt,s,t,Head[N],d[N],dep[N],low[M],cur[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w; &#125;E[M&lt;&lt;1]; inline void add(const int u,const int v,const int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; E[++cnt]=(edge)&#123;u,Head[v],0&#125;; Head[v]=cnt; &#125; void init() &#123; s=n+1,t=s+1,cnt=1; memset(d,0,sizeof(int[n+1])); memset(Head,0,sizeof(int[t+1])); &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(dep,0,sizeof(int[t+5])); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!dep[v]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]; &#125; int dfs(const int u,const int mn) &#123; if(u==t||!mn) return mn; int v,w,used=0; for(int i=Head[u];i;i=E[i].next) &#123; v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(E[i].w,mn-used)); used+=w; E[i].w-=w,E[i^1].w+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; inline int Dinic() &#123; int ans=0; while(bfs()) ans+=dfs(s,inf); return ans; &#125; void work() &#123; int T=read(); while(T--) &#123; n=read(),m=read(); init(); for(int i=1;i&lt;=m;i++) &#123; int x=read(),y=read(),l=read(),u=read(); add(x,y,u-l); low[i]=l; d[x]-=l,d[y]+=l; &#125; int tot=0,last=cnt; for(int i=1;i&lt;=n;i++) &#123; if(d[i]&lt;0) add(i,t,-d[i]); else if(d[i]&gt;0) tot+=d[i],add(s,i,d[i]); &#125; if(Dinic()!=tot) puts("NO"); else &#123; puts("YES"); for(int i=3;i&lt;=last;i+=2) printf("%d\n",low[i&gt;&gt;1]+E[i].w); &#125; puts(""); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 有源汇的上下界可行流模型给定一个有源点 $s$ 和汇点 $t$ 的网络，求出一个源点流出量=汇点流入量，其它点流量守恒的的流，并且每条边满足上下界限制。 方法发现只有源汇点流量不守恒，那么我们建一条从 $t$ 到 $s$ 的边上界为 $inf$ 下界为 $0$，把 $t$ 的流出量流入 $s$ 使它俩守恒，就变成了一个无源汇可行流了。 如果是虚拟的源汇点不连可行流的虚拟源汇点 求完后，边 $(t-&gt;s)$ 的流量就是源汇点的流量（整个网络的流量）。 代码参见最小流的部分 有源汇的上下界最大流模型在上个模块条件下要求总流量最大 方法上面那个求出来的是可行流，不一定最大，我们在残余网络上跑 $s$ 到 $t$ 的最大流即可。 最大流=可行流流量（ $t-&gt;s$ 边的流量）+ 新增广的 $s$ 到 $t$ 的最大流 注意 这里的 $s$，$t$是原图中给定的源汇点，不是求可行流时虚拟的源汇点。 要先删除了那两个虚拟的源汇点（删掉和它相连的边）和新加的边 $(t-&gt;s)$ （即将边权设为0）再算！！ 感觉没啥给代码的必要……（可以参见最小流） 有源汇的上下界最小流模型在上上一个模块条件要求下，总流量最小 方法先跑有源汇可行流，然后在残余网络上跑 $t$ 到 $s$ 的最大流，这样实际上消耗的图中的反向边，反向边流量的减少就是总流量的减少，即缩减流量。 最小流=可行流流量（ $t-&gt;s$ 边的流量）- 减去的 $t$ 到 $s$ 的最大流 因为这些边的下界并没有在图中建出，即无论怎么减少，只要边的流量还是 $\leqslant 0$ 的，它就依旧满足流量下界。 例题bzoj2502 清理雪道luogu4843 清理雪道 画个图一看数据范围这么小，这不就是个流嘛，将总部看作源点，源点可以到达任意点；再将结束看作汇点，任意点都可以到汇点。然后要求每条边至少走一次，那就是边的流量有下界为1，没有上界，求最小次数直接跑有源汇上下界最小流就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=110; const int M=10010; const int inf=0x3f3f3f3f; int n,s,t,cnt=1,Head[N],d[N],deg[N],cur[N],dep[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w; &#125;E[M&lt;&lt;2]; inline void add(const int u,const int v,const int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; E[++cnt]=(edge)&#123;u,Head[v],0&#125;; Head[v]=cnt; &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(dep,0,sizeof(int[t+5])); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!dep[v]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]; &#125; int dfs(const int u,const int mn) &#123; if(u==t||!mn) return mn; int v,w,used=0; for(int i=Head[u];i;i=E[i].next) &#123; v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(E[i].w,mn-used)); used+=w; E[i].w-=w,E[i^1].w+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; inline int Dinic() &#123; int ans=0; while(bfs()) ans+=dfs(s,inf); return ans; &#125; void work() &#123; n=read(); int ss=n+1,tt=n+2; s=n+3,t=n+4; for(int u=1;u&lt;=n;u++) &#123; int k=read(); while(k--) &#123; int v=read(); add(u,v,inf); d[u]--,d[v]++; &#125; &#125; for(int i=1;i&lt;=n;i++) add(ss,i,inf),add(i,tt,inf); add(tt,ss,inf); int ed=cnt; for(int i=1;i&lt;=n;i++) if(d[i]&gt;0) add(s,i,d[i]); else if(d[i]&lt;0) add(i,t,-d[i]); Dinic(); int flow=E[ed].w; for(int i=Head[s];i;i=E[i].next) E[i].w=E[i^1].w=0; for(int i=Head[t];i;i=E[i].next) E[i].w=E[i^1].w=0; E[ed-1].w=E[ed].w=0;//一定要删了后来加的边 s=tt,t=ss;//跑t-&gt;s的最大流 printf("%d\n",flow-Dinic()); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 因为实在是害怕不小心咕咕咕以至于忘了这码子事（忘到猴年马月），所以今天继续把费用流补上 无源汇上下界最小/大费用可行流模型在无源汇上下界可行流的基础上，要求费用最小。 方法同可行流一样，首先先将下界作为初始流（当然要把费用加上），然后按照上面一样的建图方法，就是边加上费用，其中新加的连接虚拟源汇的边费用为 $0$，跑费用流，得到的就是附加流的最小费用，加上初始流费用就是答案。 有源汇上下界最小/大费用可行流模型懒得说了，懂得 方法一样一样，连 $(t-&gt;s)$、上界 $inf$、费用 $0$ 的边，然后就可以跑无源汇上下界最小/大费用可行流了。 例题luogu 4043 [AHOI2014/JSOI2014]支线剧情bzoj 3876 [Ahoi2014&amp;Jsoi2014]支线剧情 给你一个有向无环图，每条边有一个费用，要求覆盖所有路径的条件下费用和最小。 看到路径覆盖自然网络流，配合费用就是费用流。然后路径覆盖就是每条边有一个下界为 $1$，没有上界，有源点 $1$ ，就变成了有源汇上下界最小费用可行流了，贴板贴板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=310; const int M=900010; const int inf=0x3f3f3f3f; int n,s,t,ans,Head[N],dis[N],vis[N],d[N],pre[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w,c; &#125;E[M&lt;&lt;1]; inline void add(const int u,const int v,const int w,const int c) &#123; static int cnt=1; E[++cnt]=(edge)&#123;v,Head[u],w,c&#125;; Head[u]=cnt; E[++cnt]=(edge)&#123;u,Head[v],0,-c&#125;; Head[v]=cnt; &#125; bool spfa() &#123; queue&lt;int&gt; q; memset(dis,inf,sizeof(int[t+1])); memset(pre,0,sizeof(int[t+1])); dis[s]=0,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); vis[u]=0; for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;dis[v]&gt;dis[u]+E[i].c) &#123; dis[v]=dis[u]+E[i].c; pre[v]=i; if(!vis[v]) vis[v]=1,q.push(v); &#125; &#125; &#125; return pre[t]; &#125; void mcmf() &#123; while(spfa()) &#123; int mn=inf; for(int i=pre[t];i;i=pre[E[i^1].to]) mn=min(mn,E[i].w); for(int i=pre[t];i;i=pre[E[i^1].to]) E[i].w-=mn,E[i^1].w+=mn; ans+=mn*dis[t]; &#125; &#125; void work() &#123; n=read(),s=n+2,t=s+1; for(int i=1;i&lt;=n;i++) &#123; int k=read(); d[i]-=k; while(k--) &#123; int j=read(),val=read(); d[j]++,ans+=val; add(i,j,inf,val); &#125; &#125; for(int i=2;i&lt;=n;i++) add(i,n+1,inf,0); add(n+1,1,inf,0); for(int i=1;i&lt;=n;i++) if(d[i]&gt;0) add(s,i,d[i],0); else add(i,t,-d[i],0); mcmf(); printf("%d\n",ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 完结撒花~]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小割树 学习笔记 [网络流]]]></title>
    <url>%2F2019%2F01%2F10%2F%C3%97%C3%AE%C3%90%C2%A1%C2%B8%C3%AE%C3%8A%C3%B7%2F</url>
    <content type="text"><![CDATA[问题luogu 4897 [模板] 最小割树（Gomory-Hu Tree） 给定一个 $n$ 个点 $m$ 条边的无向连通图，多次询问两点之间的最小割。 其中两点间的最小割是这样定义的：原图的每条边有一个割断它的代价，你需要用最小的代价使得这两个点不连通 $n \leqslant 500$， $m \leqslant 1500$ ，$q \leqslant 10^5$ 方法emmm……不证明的话很简单 首先有一个定理，就是一个n个点的图上，两点之间只有n种本质不同的最小割。因此一定存在一棵树，满足树上两点的最小割等于原图上两点的最小割。我们把这样的树称之为“最小割树”。 –Ebola 证明自然是没有的 在这里直接说建树方法，主要思想:分治 在图（当前点集）中任意选出来两个点 $s$ ，$t$，求出全图最小割 $flow(s,t)$，通过这条割将全图分成了两个连通块，其中 $s$ 所在的记作 $S$，$t$ 所在的记作 $T$。 引理： 对于任意的 $u \in S$，$v \in T$ ，都有 $flow(u,v) \leqslant flow(s,t)$ 证明：如果不存在，则 $flow(s,t)$ 不足以割开 $s$ 和 $t$，因为 $u$，$v$ 依旧相连。 我们在最小割树上连一条 $s$，$t$ 之间的边，边权为 $flow(s,t)$。然后再对 $S$ 和 $T$ 集合分治处理即可（做法同上）。 这样，我们分开 $n$ 个点跑了 $n$ 次网络流，建了 $n-1$ 条边，建成了一棵树，即最小割树。 时间复杂度 $n$ 次网络流 -&gt; $O(n^3 m)$，但是由于 $Dinic$ 时间复杂度比较玄学（反正我不知道），跑不满，能过。 因为是对全图的网络流（不是残余网络），所以每次网络流前要先回复其（最大）流量 12for(int i=2;i&lt;=cnt;i++) E[i].w=E[i^1].w=(E[i].w+E[i^1].w)&gt;&gt;1; 用处自然是可以快速求出两点之间最小割的。 引理：对于图上两点 $u$，$v$，他们之间的最小割是他们在最小割树的路径上的边权最小值 求树上两点路径上边权的最小值，倍增和树剖都可以。 当然！因为点数相当的少（不然用不了），完全可以 $O(n^2)$ 处理后 做到 O(1) 查询 懒人专用 代码这模板咋 $500ms$ …… $O2$ 好哇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=510; const int M=1510; const int inf=0x3f3f3f3f; int s,t,n,m,cnt=1,Head[N],tmp[N],cur[N],arr[N],vis[N],dep[N],flow[N][N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline void write(int x) &#123; int len=0;static int bask[50]; do bask[++len]=x%10,x/=10; while(x); while(len) putchar('0'+bask[len--]); putchar('\n'); &#125; struct edge &#123; int to,next,w; &#125;E[M&lt;&lt;1]; inline void add(const int u,const int v,const int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(dep,0,sizeof(int[n+1])); memcpy(cur,Head,sizeof(int[n+1])); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!dep[v]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]; &#125; int dfs(const int u,const int mn) &#123; if(u==t||!mn) return mn; int v,w,used=0; for(int &amp;i=cur[u];i;i=E[i].next) &#123; v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(mn-used,E[i].w)); used+=w; E[i].w-=w,E[i^1].w+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; inline int Dinic() &#123; int ans=0; while(bfs()) ans+=dfs(s,inf); return ans; &#125; void search(const int u) &#123; vis[u]=1; for(int i=Head[u];i;i=E[i].next) if(E[i].w&amp;&amp;!vis[E[i].to]) search(E[i].to); &#125; void solve(const int l,const int r) &#123; if(l==r) return; s=arr[l],t=arr[r]; for(int i=2;i&lt;=cnt;i+=2) E[i].w=E[i+1].w=(E[i].w+E[i+1].w)&gt;&gt;1; int f=Dinic(); memset(vis,0,sizeof(int[n+1])); search(s); for(int i=1;i&lt;=n;i++) if(vis[i]) for(int j=1;j&lt;=n;j++) if(!vis[j]) flow[i][j]=flow[j][i]=min(flow[i][j],f); int t1=l,t2=r; for(int i=l;i&lt;=r;i++) if(vis[arr[i]]) tmp[t1++]=arr[i]; else tmp[t2--]=arr[i]; memcpy(arr+l,tmp+l,sizeof(int[r-l+1])); solve(l,t1-1),solve(t2+1,r); &#125; void work() &#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(),w=read(); add(u,v,w),add(v,u,w); &#125; for(int i=1;i&lt;=n;i++) arr[i]=i; memset(flow,inf,sizeof(flow)); solve(1,n); int q=read(); while(q--) write(flow[read()][read()]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 例题[ZJOI2011] 最小割luogu3329 bzoj2229 好像很多人用的都是二分+网络流，如果你知道最小割树的话，就可以用 $floyd$ 求出两点最小割之后直接查询了 so easy! 代码代码是以前写的了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;namespace TYC&#123; const int MAXN=310,inf=0x3f3f3f3f; int n,m,cnt,s,t,Head[MAXN],vis[MAXN],a[MAXN],cur[MAXN],dep[MAXN],flow[MAXN][MAXN],tmp[MAXN]; inline int read() &#123; int x=0,f=0; char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w; &#125;E[2000010]; void add(int u,int v,int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; &#125; void init() &#123; cnt=1; memset(Head,0,sizeof(Head)); for(int i=1;i&lt;=150;i++) for(int j=1;j&lt;=150;j++) flow[i][j]=inf; &#125; void clear() &#123; for(int i=2;i&lt;=cnt;i++) E[i].w=E[i^1].w=(E[i].w+E[i^1].w)&gt;&gt;1; &#125; bool bfs() &#123; memset(dep,-1,sizeof(dep)); queue&lt;int&gt; q; dep[s]=0; q.push(s); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;dep[v]==-1) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]!=-1; &#125; int dfs(int u,int mn) &#123; if(u==t) return mn; int w,used=0; for(int &amp;i=cur[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(mn-used,E[i].w)); E[i].w-=w,E[i^1].w+=w; used+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; int Dinic() &#123; int ans=0; while(bfs()) &#123; memcpy(cur,Head,sizeof(cur)); ans+=dfs(s,inf); &#125; return ans; &#125; void dfs1(int u) &#123; vis[u]=1; for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!vis[v]) dfs1(v); &#125; &#125; void solve(int l,int r) &#123; if(l==r) return; s=a[l],t=a[r]; clear(); int f=Dinic(); //Tree: add_edge(s,t,f) 如果要建树 memset(vis,0,sizeof(vis)); dfs1(s); for(int i=1;i&lt;=n;i++) if(vis[i]) for(int j=1;j&lt;=n;j++) if(!vis[j]) flow[i][j]=flow[j][i]=min(flow[i][j],f); int L=l,R=r; for(int i=l;i&lt;=r;i++) if(vis[a[i]]) tmp[L++]=a[i]; else tmp[R--]=a[i]; for(int i=l;i&lt;=r;i++) a[i]=tmp[i]; solve(l,L-1),solve(R+1,r); &#125; void work() &#123; int T=read(); while(T--) &#123; init(); n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(),w=read(); add(u,v,w),add(v,u,w); &#125; for(int i=1;i&lt;=n;i++) a[i]=i; solve(1,n); int q=read(); while(q--) &#123; int x=read(),ans=0; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(flow[i][j]&lt;=x) ans++; printf("%d\n",ans); &#125; puts(""); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 参考资料UranusITS的博客-最小割树]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2534 L-gap字符串 [SAM] [线段树] [启发式合并]]]></title>
    <url>%2F2019%2F01%2F08%2Fbzoj2534Uva10829L-gap%C3%97%C3%96%C2%B7%C3%BB%C2%B4%C2%AE-SAM%2F</url>
    <content type="text"><![CDATA[题意bzoj2534 给你一个字符串 $S$，以及一个 $L$。 求 $S$ 中有多少个形如 $uvu$ 的子串，其中 $u$ 非空，且 $v$ 的长度恰好为 $L$。 其中 $len(S) \leqslant 50000$ ，$L \leqslant 10$。 分析讲道理数据里面居然全是大写字母 总感觉自己YY出来了什么神奇的东西，网上好像用 $SA$ 的比较多。 看到字符串第一个想 $SAM$ （被我校 $SAM$ 之神兔子教坏了） 考虑对于一个某个点 $now$ 的 $right$ 集合中的一个元素 $k$ ，它所能产生的贡献是在区间 $[k-L-mx[now],k-L-1]$ 或者 $[k+L+1,k+L+mx[now]]$ 并且在这个点的 $right$ 的集合中的点的个数 （$k-L-1$ 保证 $u$ 不为空）。 因为合并 $right$ 集合的时候，每一个点对仅会出现一次（或者说产生一次贡献），所以区间并不是在 $now$ 的长度 $[min,max]$ 之间，而是任意可行的长度 ($u$ 相同，即 $max$ 以内），因为在这个长度范围内的都是合法，并且下次不会被重复算到（合并后就不会再枚举到这个点对了）。 相当于两个右端点在 $parent$ 树上的 $LCA$ 处计算贡献。 那么就很简单了，建 $SAM$ 用线段树维护 $right$ 集合（用于求区间中点的个数），启发式合并，合并的时候统计 $y$ 合并入 $x$ 时 $y$ 中的点与 $x$ 中的点的贡献。 因为比较懒，所以再用了一个 $set$ 辅助启发式合并。 写完了感觉很奇怪因为并没有用到 $L \leqslant 10$ 这个条件…… 代码不要忘了左右两个区间都行，启发式合并交换 $set$ 的时候不要忘了交换线段树的根（合并了就可以扔掉 $y$ 了） 因为线段树启发式合并是 $O(n log^2 n)$ 的，所以空间也要开到 $O(n log^2 n)$ 。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; char s[50010];int n,L; long long ans; namespace Tree &#123; const int M=50000*70+10; int cnt,ls[M],rs[M],val[M]; void insert(int &amp;root,const int l,const int r,const int pos) &#123; if(!root) root=++cnt; ++val[root]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(ls[root],l,mid,pos); else insert(rs[root],mid+1,r,pos); &#125; int query(const int root,const int l,const int r,const int s,const int e) &#123; if(!root) return 0; if(s&lt;=l&amp;&amp;r&lt;=e) return val[root]; int mid=(l+r)&gt;&gt;1,ans=0; if(s&lt;=mid) ans+=query(ls[root],l,mid,s,e); if(e&gt;mid) ans+=query(rs[root],mid+1,r,s,e); return ans; &#125; &#125; namespace SAM &#123; const int N=100010; int last=1,tot=1,root[N]; struct node &#123; int fa,mx,son[26]; &#125;tr[N]; set&lt;int&gt; right[N]; typedef set&lt;int&gt;::iterator iter; void insert(const int c,const int pos) &#123; int now=++tot,p=last; tr[now].mx=tr[p].mx+1; right[now].insert(pos); Tree::insert(root[now],1,n,pos); while(p&amp;&amp;!tr[p].son[c]) tr[p].son[c]=now,p=tr[p].fa; if(!p) tr[now].fa=1; else &#123; int q=tr[p].son[c]; if(tr[q].mx==tr[p].mx+1) tr[now].fa=q; else &#123; int clone=++tot; tr[clone]=tr[q]; tr[clone].mx=tr[p].mx+1; tr[q].fa=tr[now].fa=clone; while(p&amp;&amp;tr[p].son[c]==q) tr[p].son[c]=clone,p=tr[p].fa; &#125; &#125; last=now; &#125; void merge(const int x,const int y) &#123; if(right[x].size()&lt;right[y].size()) right[x].swap(right[y]),swap(root[x],root[y]); for(iter it=right[y].begin();it!=right[y].end();it++) &#123; int l=max(1,*it-L-tr[x].mx),r=min(n,*it-L-1); if(l&lt;=r) ans+=Tree::query(root[x],1,n,l,r); l=*it+L+1,r=min(n,*it+L+tr[x].mx); if(l&lt;=r) ans+=Tree::query(root[x],1,n,l,r); &#125; for(iter it=right[y].begin();it!=right[y].end();it++) &#123; Tree::insert(root[x],1,n,*it); right[x].insert(*it); &#125; &#125; void radix_sort() &#123; static int bask[N],q[N]; for(int i=1;i&lt;=tot;i++) bask[tr[i].mx]++; for(int i=1;i&lt;=tot;i++) bask[i]+=bask[i-1]; for(int i=tot;i;i--) q[bask[tr[i].mx]--]=i; for(int i=tot;i;i--) merge(tr[q[i]].fa,q[i]); &#125; &#125; void work() &#123; scanf("%d%s",&amp;L,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;i++) SAM::insert(s[i]-'A',i); SAM::radix_sort(); printf("%lld\n",ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkCutTree动态树 学习笔记 [数据结构]]]></title>
    <url>%2F2019%2F01%2F05%2FLinkCutTree%2F</url>
    <content type="text"><![CDATA[upd in 2019.1.8 ： 真是震惊极了……我打了这么久的板子（包括网上某些LCT讲解中的代码）竟然复杂度是假的！！！ 因为 splay 的复杂度是均摊的，每一次从根遍历了一条链就要将链尾 splay 上去（例如，如果当前的 splay 树形是一条长为 $n$ 递增的链-&gt;最大点为根，$m$ 次查询，每次查询第一个，如果不这样复杂度就变成 $O(mn)$ 了），才能保证复杂度均摊 $O(log n)$ 所以，在 $findroot$ 后，应当将最后的 $x$ splay 到根。 别忘了修改一下 $cut(x,y)$ 的部分，要先判完 $findroot(x)==findroot(y)$ 再 $split(x,y)$ ，否则树形会被修改。 模板的代码是修改过的了，魔法森林的就不改了（以作对比） 顺便献上发现原因 uoj274 [清华集训2016]温暖会指引我们前行修改前修改后（不要在意第 $20$ 个点的时间……） 写在前面最近一直在补之前欠了好久的锅，像后缀自动机啊什么的，总算轮到 LCT 了，感觉也挺对不起的，学了这么久的 OI 了现在才学会这个…… 但毕竟这个学习笔记主要还是给自己复习这个算法（老是忘）的时候看的，也就不讲的那么清楚了反正写这篇博客的时候我还是会的 概述LCT实际是实链剖分，就是只有一个其中儿子的边的实边，其他的都是虚边，但是因为虚实可以动态变化，所以要用 splay 维护。 每一棵 splay 维护的是一条实链的信息，构成一个 splay 森林（原来的其实也是一个森林）。其中满足：1、splay 按照深度为关键字对原树上节点排序，中序遍历 splay 树得到的是该实链的深度严格递增的排列。2、每个节点在且仅在一棵 splay 中3、父亲只认实儿子，儿子认父亲。（所以当一个点是它所在的实链的根的条件就是他的父亲没有他这个儿子） 因为原树是没有根的，所以本身也没有深度这一说，但是 LCT 中要指定一个根才行（然后就有了换根的操作） 可以资瓷：1、查询、修改链上的信息 （子树不行！！！）2、指定原树上一个点作为根（就是上面说的换根）3、连边、删边、动态维护连通性4、挖坑留给以后见到的神奇用法 操作$isroot(x)$判断 $x$ 是不是它所在实链的根 -&gt; $x$ 不是 $fa[x]$ 的任意一个儿子。 $access(x)$这个操作很重要所以要大一点打通 $x$ 到 $x$ 的路径为新的实链，即 $x$ 到 $x$ 的路径上的点维护在一棵 splay 中（没有图，所以只能感性理解） 方法： 1、将 $x$ splay 到所在实链的根，断开他的右子树 (深度比他大的点就不认了） 2、再看 $fa[x]$ 这个点，同样把它转到根，将刚刚的 $x$ 所在实链接在右子树上。 3、将 $x$ 变成 $fa[x]$，反复进行操作2直到 $fa[x]$ 不存在 12345inline void access(int x)&#123; for(int tmp=0;x;tmp=x,x=fa[x]) splay(x),son[x][1]=tmp,update(x);&#125; $makeroot(x)$将 $x$ 作为原树的根，会修改的就是 splay 上按照深度的遍历顺序，因为 $access(x)$ 后 $x$ 一定是所在实链上深度最大的点，当 $x$ splay 到根时，是不会有右子树的，直接 $reverse$ 左右子树就达到了反转序列的效果了。 所以要打一个 $rev$ 的 $tag$ （和系列的 $pushdown$ 操作） 12345inline void reverse(const int &amp;root) &#123;rev[root]^=1,swap(ls,rs);&#125;inline void makeroot(const int root) &#123; access(root),splay(root),reverse(root);&#125; 因为有了 $tag$ ，splay的时候就要注意 $pushdown$ 避免转错了。先将 $x$ 到 $root$ 的路径上点从上到小 $pushdown$ 完再 splay 吧。 $findroot(x)$找到 $x$ 所在原树上的根，用于判断连通性。方法：$access(x)$ 后 $x$ 所在 $splay$ 中深度最小的点（序列最左）的便是根了，再将 $x$ splay 到根，一路找左儿子便能找到根了。123456inline int findroot(int root)&#123; access(root),splay(root); while(ls) pushdown(ls),root=ls; return root;&#125; upd:某位神仙告诉我splay了就不用pushdown了（好像很有道理）OrzOrz $split(x,y)$因为经常要求的是两点之间路径的情况，光是一个点到根是不够的，所以就有了 $split(x,y)$ 用于将 $x$ 的 $y$ 路径上的点放在一个 splay 中方便查询。方法：将 $x$ 变成根以后，$access(y)$ 得到的便是 上述的 splay 了，此时再将 $y$ 转到根，便可以直接通过 $y$ 得到整个 splay （这条路径） 的所有信息了。1234inline void split(const int x,const int y)&#123; makeroot(x),access(y),splay(y);&#125; $link(x,y)$将 $x$ 变成根以后，将 $X$ 的父亲置成 $y$ 便是连边 $x$、$y$ 了。别忘了判断当前的 $y$ 是不是已经在 $x$ 所在的树中了。12345inline void link(const int x,const int y)&#123; makeroot(x); if(findroot(y)!=x) fa[x]=y;&#125; $cut(x,y)$如果保证存在边 $(x,y)$ 的话，$split(x,y)$ 后 $y$ 为根，$x$ 必为 $y$ 的左儿子（深度比 $y$ 小一），直接 $fa[x]=son[y][0]=0$断掉就行。 但是当不保证时需要满足:1&gt; $x$ 和 $y$ 在同一棵树中2&gt; $split(x,y)$ 后 $son[y][0]==x$3&gt; $split(x,y)$ 后 $x$ 没有右子树（因为 $x$ 的后继只应该是 $y$） 三个条件缺一不可 1234567inline void cut(const int x,const int y)&#123; split(x,y); if(findroot(x)!=findroot(y)||son[y][0]!=x||son[x][1]) return; fa[x]=son[y][0]=0; update(y);&#125; 若还有别的操作待补 例题一、luogu3690 [模板]Link Cut Tree(动态树)洛咕就是上面说的那些操作啦，splay 维护一下链 xor 和 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=3e5+10; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline void write(int x) &#123; int len=0;static int bask[50]; do bask[++len]=x%10,x/=10; while(x); for(;len;len--) putchar('0'+bask[len]); putchar('\n'); &#125; int val[N]; namespace LinkCutTree &#123; int son[N][2],fa[N],sum[N],rev[N]; #define ls son[root][0] #define rs son[root][1] inline int dir(const int &amp;root) &#123;return son[fa[root]][1]==root;&#125; inline bool isroot(const int &amp;root) &#123;return son[fa[root]][0]!=root&amp;&amp;son[fa[root]][1]!=root;&#125; inline void update(const int &amp;root) &#123;sum[root]=sum[ls]^sum[rs]^val[root];&#125; inline void reverse(const int &amp;root) &#123;rev[root]^=1,swap(ls,rs);&#125; inline void pushdown(const int &amp;root) &#123; if(rev[root]) return; if(ls) reverse(ls); if(rs) reverse(rs); rev[root]=1; &#125; inline void rotate(const int &amp;root) &#123; int f=fa[root],d=dir(root); if(!isroot(f)) son[fa[f]][dir(f)]=root; fa[root]=fa[f]; fa[son[root][d^1]]=f; son[f][d]=son[root][d^1]; son[root][d^1]=f,fa[f]=root; update(f),update(root); &#125; inline void splay(const int &amp;root) &#123; static int tot,list[N]; list[tot=1]=root; for(int x=root;!isroot(x);x=fa[x]) list[++tot]=fa[x]; for(int i=tot;i;i--) pushdown(list[i]); for(;!isroot(root);rotate(root)) if(!isroot(fa[root])) rotate(dir(fa[root])^dir(root)?root:fa[root]); &#125; inline void access(int root) &#123; for(int tmp=0;root;tmp=root,root=fa[root]) splay(root),son[root][1]=tmp,update(root); &#125; inline void makeroot(const int root) &#123; access(root),splay(root),reverse(root); &#125; inline void split(const int x,const int y) &#123; makeroot(x); access(y); splay(y); &#125; inline int findroot(int root) &#123; access(root),splay(root); while(ls) pushdown(ls),root=ls; splay(root); //保证复杂度！！！ return root; &#125; inline void link(const int x,const int y) &#123; makeroot(x); if(findroot(y)!=x) fa[x]=y; &#125; inline void cut(const int x,const int y) &#123; if(findroot(x)!=findroot(y)) return; split(x,y); if(son[y][0]!=x||son[x][1]) return; fa[x]=son[y][0]=0; update(y); &#125; &#125; void work() &#123; int n=read(),m=read(); for(int i=1;i&lt;=n;i++) val[i]=read(); using namespace LinkCutTree; while(m--) &#123; int op=read(),x=read(),y=read(); switch(op) &#123; case 0: split(x,y),write(sum[y]);break; case 1: link(x,y);break; case 2: cut(x,y);break; case 3: val[x]=y,splay(x); &#125; &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 后来都把 root 打成 x 了，四个字母看着好长 二、bzoj3669 [Noi2014]魔法森林洛咕2387 bzoj3669 先按照 $a$ 排序，然后对于边 $edge(u,v)$ 判断：当 $u$，$v$ 没有连通时，加上 $edge$；否则，找到连通 $u$，$v$ 的边中 $b$ 最大的边 $t$，如果 $b(t) &gt; b(edge)$，用 $edge$ 替换 $t$。（删掉 $t$ 加上 $edge$） 每次判断 $1$ 是否已经连通 $n$，若已连通，更新$ans=min(ans,a(edge)+1到n路径上b的最大值)$ 对于动态加边、删边、维护连通性和查询两点最大权值用 LCT 解决。 但是由于 LCT 只能存储点的信息（边不行），所以我们将一条边也看作一个点.若要加上边 $edge$，就相当于 $link(u,edge)$、$link(edge,v)$。 代码还是挺好写的，$cut$ 的时候写成了 $fa[y]=son[y][0]=0$ 调了好久……偷懒记了一些神奇的东西123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=1e5+10; const int inf=0x3f3f3f3f; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int u,v,a,b; bool operator &lt; (const edge &amp;t) const &#123; return a&lt;t.a; &#125; &#125;e[100010]; namespace LinkCutTree &#123; int son[N][2],fa[N],val[N],rev[N],id[N],mx[N],idedge[N]; #define ls son[x][0] #define rs son[x][1] inline bool isroot(const int &amp;x) &#123;return son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x;&#125; inline int dir(const int &amp;x) &#123;return son[fa[x]][1]==x;&#125; inline void reverse(const int &amp;x) &#123;rev[x]^=1,swap(ls,rs);&#125; inline int Max(const int &amp;x,const int &amp;y) &#123;return val[x]&gt;val[y]?x:y;&#125; inline void update(const int &amp;x) &#123;mx[x]=Max(Max(mx[ls],mx[rs]),id[x]);&#125; inline void pushdown(const int &amp;x) &#123; if(!rev[x]) return; if(ls) reverse(ls); if(rs) reverse(rs); rev[x]=0; &#125; inline void rotate(const int &amp;x) &#123; int f=fa[x],d=dir(x); if(!isroot(f)) son[fa[f]][dir(f)]=x; fa[x]=fa[f]; son[f][d]=son[x][d^1]; fa[son[x][d^1]]=f; son[x][d^1]=f,fa[f]=x; update(f),update(x); &#125; inline void splay(const int &amp;x) &#123; static int tot,list[N]; list[tot=1]=x; for(int i=x;!isroot(i);i=fa[i]) list[++tot]=fa[i]; for(int i=tot;i;i--) pushdown(list[i]); for(;!isroot(x);rotate(x)) if(!isroot(fa[x])) rotate(dir(x)^dir(fa[x])?x:fa[x]); &#125; inline void access(int x) &#123; for(int t=0;x;t=x,x=fa[x]) splay(x),son[x][1]=t,update(x); &#125; inline void makeroot(const int &amp;x) &#123; access(x),splay(x),reverse(x); &#125; inline void split(const int &amp;x,const int &amp;y) &#123; makeroot(x),access(y),splay(y); &#125; inline int find(int x) &#123; access(x),splay(x); while(ls) pushdown(x),x=ls; return x; &#125; inline void link(const int &amp;x,const int &amp;y) &#123; makeroot(x); if(find(y)!=x) fa[x]=y; &#125; inline void cut(const int &amp;x,const int &amp;y) &#123; split(x,y); if(son[y][0]!=x||son[x][1]) return; fa[x]=son[y][0]=0; update(y); &#125; inline int query(const int &amp;x,const int &amp;y) &#123; split(x,y); return mx[y]; &#125; &#125; void work() &#123; int n=read(),m=read(),ans=inf; for(int i=1;i&lt;=m;i++) e[i]=(edge)&#123;read(),read(),read(),read()&#125;; sort(e+1,e+1+m); using namespace LinkCutTree; for(int i=1,tot=n;i&lt;=m;i++) &#123; int u=e[i].u,v=e[i].v,w=e[i].b; if(find(u)==find(v)) &#123; int ed=query(u,v); if(val[ed]&lt;=w) continue; cut(e[idedge[ed]].u,ed),cut(e[idedge[ed]].v,ed); val[ed]=w,idedge[ed]=i; link(u,ed),link(v,ed); &#125; else &#123; val[++tot]=w,id[tot]=tot; idedge[tot]=i; link(u,tot),link(v,tot); &#125; if(find(1)==find(n)) ans=min(ans,e[i].a+val[query(1,n)]); &#125; printf("%d\n",ans==inf?-1:ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 一粘代码就显得好长…… 参考资料FlashHu http://www.cnblogs.com/flashhu/p/8324551.htmlCandy? https://www.cnblogs.com/candy99/p/6271344.html]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2154 Crash的数字表格 [莫比乌斯反演]]]></title>
    <url>%2F2018%2F12%2F16%2Fbzoj2154Crash%C2%B5%C3%84%C3%8A%C3%BD%C3%97%C3%96%C2%B1%C3%AD%C2%B8%C3%B1-%C3%8A%C3%BD%C3%91%C2%A7%2F</url>
    <content type="text"><![CDATA[题意bzoj2154luogu1829 给定两个数 $n$，$m$（ $n，m \leqslant 1e7$ ），求$$\sum_{i=1}^n \sum_{j=1}^m lcm(i,j)$$ 分析这篇题解是很早以前写的了，然后搬到了博客上……果然，人总要为一些很傻的事情付出代价，就像当时的我知道 markdown 怎么转成 PDF 后删掉 markdown 源码的一样。emmmmm……大力图片 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int p=20101009,N=1e7+10; const int inv2=(p+1)/2; int n,m,cnt,mu[N],prime[N]; ll sum[N]; bool vis[N]; inline void init(int maxn) &#123; mu[1]=1; for(int i=2;i&lt;=maxn;i++) &#123; if(!vis[i]) prime[++cnt]=i,mu[i]=-1; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*prime[j])&lt;=maxn;j++) &#123; vis[k]=1; if(i%prime[j]==0) &#123;mu[k]=0;break;&#125; mu[k]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=maxn;i++) sum[i]=(sum[i-1]+1LL*i*i*mu[i]%p)%p; &#125; inline ll cal(ll x) &#123; return (1+x)*x%p*inv2%p; &#125; ll F(int x,int y) &#123; ll ans=0,limit=min(x,y); for(ll l=1,r;l&lt;=limit;l=r+1) &#123; r=min(x/(x/l),y/(y/l)); ans=(ans+cal(x/l)*cal(y/l)%p*(sum[r]-sum[l-1]+p)%p)%p; &#125; return ans; &#125; void work() &#123; scanf("%d%d",&amp;n,&amp;m); ll limit=min(n,m),ans=0; init(limit); for(ll d=1,last;d&lt;=limit;d=last+1) &#123; last=min(n/(n/d),m/(m/d)); ans=(ans+(d+last)*(last-d+1)%p*inv2%p*F(n/d,m/d)%p)%p; &#125; printf("%lld\n",(ans+p)%p); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4591 [SHOI2015]超能粒子炮·改 [数学]]]></title>
    <url>%2F2018%2F12%2F16%2Fbzoj4591%C2%B3%C2%AC%C3%84%C3%9C%C3%81%C2%A3%C3%97%C3%93%C3%85%C3%9A-%C2%B8%C3%84-%C3%8A%C3%BD%C3%91%C2%A7%2F</url>
    <content type="text"><![CDATA[题目bzoj4591luogu4345 $t \ (t \leqslant 1e5)$ 组询问，每次给定两个数 $n、k \ (n、k \leqslant 1e18)$，求$$\sum_{i=0}^k C_n^i \mod 2333$$ 分析emmmm……和bzoj2154那篇题解一样的命运 但是不知道为什么这个 PDF 显示的 $\LaTeX$ 这么粗 （ 好丑 ），勉强看一下 毕竟实在懒得再打了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;namespace TYC&#123; const int p=2333,N=2350; typedef long long ll; int C[N][N],f[N][N]; inline ll read() &#123; ll x=0;int f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline int Mod(int x) &#123;return x&gt;=p?x-p:x;&#125; inline void init() &#123; C[0][0]=1; for(int i=1;i&lt;p;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=Mod(C[i-1][j-1]+C[i-1][j]); &#125; for(int i=0;i&lt;p;i++) for(int j=0;j&lt;p;j++) f[i][j]=Mod(f[i][j-1]+C[i][j]); &#125; inline int Lucas(ll n,ll m) &#123; if(!m) return 1; if(n&lt;m) return 0; return C[n%p][m%p]*Lucas(n/p,m/p)%p; &#125; inline int F(ll n,ll k) &#123; if(!k||!k) return 1; if(n&lt;p&amp;&amp;k&lt;p) return f[n][k]; return Mod(f[n%p][p-1]*F(n/p,k/p-1)%p+Lucas(n/p,k/p)*f[n%p][k%p]%p); &#125; void work() &#123; init(); int T=read(); while(T--) &#123; ll n=read(),k=read(); printf("%d\n",F(n,k)); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ531「LibreOJ β Round 5」游戏 [基环树] [博弈]]]></title>
    <url>%2F2018%2F12%2F16%2Floj531%C3%93%C3%8E%C3%8F%C2%B7-%C2%BB%C3%B9%C2%BB%C2%B7%C3%8A%C3%B7%2F</url>
    <content type="text"><![CDATA[题面loj531.「LibreOJ β Round #5」游戏 题目描述LCR 发现，精确匹配是通过与随机对手（称为「神犇」）游戏的方式，藉由游戏的决策来评定智商的机制。游戏规则如下： 有一个长为 $n$，下标为 $[1,n]$, 的数组 $f[\ ]$，且满足 $f[i]\in [1,n]$。 有一个变量 $a$ 初始值为 $1$。双方轮流操作，LCR 先手。 操作方法：每次在所有满足 $f[i]=a$ 的 $i$ 中选一个，并将 $a$ 赋值为 $i$，不能不选。无法操作者输，若共 $2n$ 次操作后仍未决出胜负，则为平局。 我们定义二元关系“到达”如下： 1、$i$ 可以到达 $i$2、$i$ 可以到达 $f[i]$3、如果 $i$ 能到达 $j$，$j$ 能到达 $k$，则 $i$ 能到达 $k$。则 $f$ 数组满足性质：对于任意 $i$,$j$ 存在 $k$ 使得 $i$ 和 $j$ 都能到达 $k$。 LCR 即将面对 $q$ 局游戏。她发现每局游戏的 $f[]$ 数组都和给定的「模板数组」很像。经过进一步研究她发现每局游戏可以描述如下： 给出两个整数 $u$,$v$，满足在模板数组中 $f[u]$ 能到达 $u$，$f[v]$ 能到达 $v$。则该局游戏的 $f[]$ 是把模板数组的 $f[u]$ 赋值为 $v$ 后得到的。 现在 LCR 希望你帮她计算每局游戏的胜负状态。 输入格式第一行两个正整数 $n$,$q$。 第二行 $n$ 个整数表示 $f[]$。 接下来 $q$ 行每行两个整数 $u,v$ 描述一局游戏。 输出格式输出共 $q$ 行。 每行一个整数 $r$ 表示结果。 $r=1$ 表示先手（LCR）有必胜策略，$r=0$ 表示后手（神犇）有必胜策略，$r=2$ 表示平局。 样例输入7 33 1 2 3 4 3 21 12 32 1 样例输出200 分析这个题目怎么这么 $wqwqqwqwq$ …… 首先先看”到达”，其中 i 可以到达 f[i] 说明我们可以对于每一个 $i$ 建一条边 $i \ -&gt;f[i]$ ，然后就建成了一个 $n$ 个点 $n$ 条边的 基环内向森林 ，然后又因为 f数组满足性质：对于任意 i、j 存在 k 使得 i 和 j 都能到达 k，说明整个图是联通的，那么就得到了一棵 基环内向树 。 再分析询问中 满足 f[u] 能到达 u ，f[v] 能到达 v，原本就有边 $u \ -&gt;f[u]$，现在又得知存在有 $f[u]-&gt;u$，说明点 $u$、$f[u]$ 在基环上，点 $v$、$f[v]$ 同理。 题目理解完了，来一些博弈的简单前置技能 我们将一个状态（情况）看作一个点，从它向它能够一步转移（转移：变化成一个新状态）的状态连有向边，那么就有 一个状态如果能够转移到一个必败状态，那么它是必胜状态；如果它能转移到的全部是必胜状态，那么它是必败状态。 如果它两者皆不是（转移边构成了一个环），那么它是平局状态 考虑 $f[i]=x$ 意味着什么：当 $a=x$，$a$ 就会转移成 $i$ ，那么说明博弈的决策边应当为 $f[i]-&gt;i$ （变成基环外向树了），每次从点 $1$ 向沿决策边转移。 遇到基环外向树，果断先找环，我们从外向树向环上的点递推，就可以得到 $win[i] \in {0,1}$ 表示如果从点 $i$ 向外走，最后是否能够必胜。就可以得到所有状态的情况了。 我们记出度 $deg[ \ \ ]$，不断找没有出度的点，从 $i$ 走到 $f[i]$，并更新 $win[f[i]]$ 和$deg[f[i]]$ 即可，遍历过的点记 $deg[i]=-1$ 表示 $i$ 存在过出度减为 $0$ 的情况（即点 $i$ 不在环上，因为环上的点必然会有出度）。 当点 $1$ 不在环上时，它只存在唯一 一种决策，修改环上 $u$、$v$ 的连边对它没有影响，直接输出 $win[1]$ 即可。 否则点 $1$ 必然在环上，那么我们爬边 $i-&gt;f[i]$ 就可以遍历整个环，记下来。但是因为它与我们实际决策树的边相反，应当改成 $f[i]-&gt;i$ ，即要交换点 $id[i]-1$ $(f[x]==i 的点 x)$ 和 $id[i]+1 (f[i])$ ，再重新标号后就会有 $id[f[i]]+1==id[i]$ ，即边为 $f[i]-&gt;i$ （标号表现了它到点 $1$ 的距离）。 然后我们记 $near[i]$ 为距离点 $i$ 最近的必胜点 （不存在必胜点即为 $0$），在环上反着搜表示从点 $1$ 出发，即 12for (int i = num; i; i--) near[i] = (win[loop[i]] ? i : near[i + 1]); 现在如果我们要找 $l$ ~ $r$ 的链上找是否有必胜点时，直接查 $near[l]$ 即可 12345int query(int l, int r) &#123; if (l &gt; r) return 0; return near[l] &lt;= r ? near[l] : 0;&#125; 好，处理完了后我们来看询问。（心累累） 首先先把 $u$、$v$ 变成它在环上的标号 $id$ ，考虑：将 $f[u]=v$ 后原本边 $f[u]-&gt;u$ 就变成了 $v-&gt;u$ ，原本的边被断掉了。 分类讨论 一 、$u&gt;v$ 如图 从 $1$ 到 $v$ 存在有一个必胜点 $t$，则一定会走到这个点，直接输出 $t \&amp; 1$ 即为走到 $t$ 获胜的人。 不存在必胜点时，再判断： ​ 如果链 $v+1$ 到 $f[u] \ (u-1)$ 上存在有一个必胜点 $t$ 且与点 $v$ 的奇偶性相同，则走到 $v$ 的人一定会选择走这 条链走到点 $t$ 取胜；如果没有它可以一直走到 $f[u]$ 逼的对手无路可走，即点 $f[u]$ 的奇偶性与 $v$ 不同（即 $u$ 与 $v$ 的奇偶性相同），他也会走这条路 。最终结果都会使走到 $v$ 的人取胜。 123tmp = query(v + 1, u - 1); if ((tmp &amp;&amp; ((tmp &amp; 1) == (v &amp; 1))) || (!tmp &amp;&amp; ((u &amp; 1) == (v &amp; 1)))) printf("%d\n", v &amp; 1); 否则，走到 $v$ 的人就会选择走新边 $v-&gt;u$ 了（因为不走自己也赢不了），那么再判断： ​ 如果从 $u+1$ 到 $num$ 都没有必胜点，然后就相当于整个环上都没有必胜点了，平局；存在时，原本走到 $t$ 的人（$t\&amp;1$） 还要因为走了边 $v-&gt;u$ 改变奇偶性，即 (u &amp; 1) ^ (v &amp; 1) ^ (tmp &amp; 1) ^ 1。 二 、$u&lt;v$ 首先，当 $u \neq 1$ 时，如图 ​ 就只能从点 $1$ 走到 $f[u]$ 直接看这条路上有没有必胜点，没有就看谁走到了尽头点 $f[u]$ 当 $u = 1$ 时，相当于断开了 $fa[1]-&gt;1$ 的边，连上了 $v-&gt;1$ ​ 那么，如果 $1-&gt;v$ 上有必胜点，就直接到必胜点了，否则考虑：如果 $v-&gt;f[u]$ 上有必胜点，况且走到 $v$ 的人刚好走到这个必胜点，或者走到 $v$ 的人刚好走到 $f[u]（num）$ 使对方无路可走，那么他就就会选择走 $v-&gt;f[u]$ 的边取胜。 ​ 否则，他就只能走新边 $v-&gt;1$ ，但是 $1-&gt;v$ 上又没有必胜点，就变成了平局。 代码终于可以看代码了…… 代码风格又变了（突然开始打空格） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define _namespace TYC&#123; const int N = 1e6 + 10; int n, m, num, fa[N], deg[N], win[N], loop[N], id[N], near[N]; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while(!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void dfs(int u) &#123; deg[u] = -1; if (win[u] == 0) win[fa[u]] = 1; deg[fa[u]]--; if (!deg[fa[u]]) dfs(fa[u]); &#125; int query(int l, int r) &#123; if (l &gt; r) return 0; return (near[l] &lt;= r ? near[l] : 0); &#125; void work() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) deg[fa[i] = read()]++; for (int i = 1; i &lt;= n; i++) if (!deg[i]) dfs(i); if (deg[1] == -1) &#123; while (m--) printf("%d\n", win[1]); return; &#125; for (int now = 1; !num || now != 1; now = fa[now]) loop[++num] = now; for (int i = 2; i &lt;= num - i + 2; i++) swap(loop[i], loop[num - i + 2]); for (int i = 1; i &lt;= num; i++) id[loop[i]] = i; for (int i = num; i; i--) near[i] = (win[loop[i]] ? i : near[i + 1]); while (m--) &#123; int u = read(), v = read(); u = id[u], v = id[v]; if (u &gt; v) &#123; int tmp = query(1, v); if (tmp) printf("%d\n", tmp &amp; 1); else &#123; tmp = query(v + 1, u - 1); if ((tmp &amp;&amp; ((tmp &amp; 1) == (v &amp; 1))) || (!tmp &amp;&amp; ((u &amp; 1) == (v &amp; 1)))) printf("%d\n", v &amp; 1); else &#123; tmp = query(u, num); if (!tmp) printf("2\n"); else printf("%d\n", (u &amp; 1) ^ (v &amp; 1) ^ (tmp &amp; 1) ^ 1); &#125; &#125; &#125; else &#123; if (u != 1) &#123; int tmp = query(1, u - 1); if (!tmp) printf("%d\n", u &amp; 1); else printf("%d\n", tmp &amp; 1); &#125; else &#123; int tmp = query(1, v); if (tmp) printf("%d\n", tmp &amp; 1); else &#123; tmp = query(v + 1, num); if((tmp &amp;&amp; (tmp &amp; 1) == (v &amp; 1)) || (!tmp &amp;&amp; (num &amp; 1) != (v &amp; 1))) printf("%d\n", v &amp; 1); else printf("2\n"); &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; TYC::work(); return (0^_^0);&#125; 最后快膜LCA]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>基环树</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3157/3516 国王奇遇记 [数学]]]></title>
    <url>%2F2018%2F12%2F16%2Fbzoj3157%263516%C2%B9%C3%BA%C3%8D%C3%B5%C3%86%C3%A6%C3%93%C3%B6%C2%BC%C3%87-%C3%8A%C3%BD%C3%91%C2%A7%2F</url>
    <content type="text"><![CDATA[题意$$\sum_{i=0}^n i ^ m \times m ^ i$$ 其中 $1 \leqslant n \leqslant 10^9$ ， $1 \leqslant m \leqslant N$ ，其中的 $N$ 是因为这个题有三个版本$$\begin{align}&amp;bzoj3157 - N \leqslant 200 \&amp;bzoj3516 - N \leqslant 1000 \&amp;b bzoj4126 - N \leqslant 500000 \\end{align}$$但我只会 $O(m^2)$ 的，所以先不提第三题（挖坑待填） 分析发现 $n$ 很大，不能直接枚举 $i$ ，考虑从 $m$ 入手 递推 记 $f_{n,a} = \sum_{i=0}^n i^a m^i$ （这里 $i$ 从 $0$ 开始方便后面转换，$i =0$ 对答案没有影响），题目要求 $f_{n,m}$ ，考虑转移$$\begin{align}f_{n,a} &amp;= \sum_{i=0}^n i^a m^i \&amp;= m \sum_{i=0}^n i^a m^{i-1} \ \ \ //提出一个m \&amp;= m \sum_{i=0}^{n-1} (i+1)^a m^i \ \ \ //用 \ i \ 表示 \ i+1 \\end{align}$$当 $i = -1$ 时 $(i+1)^a =0$ 大力不理 再根据二项式定理 $(a+b)^n = \sum_{i=0}^n C_n^i a^i b^{n-i}$$$\begin{align}&amp;= m \sum_{i=0}^{n-1} m^i \ \sum_{k=0}^a C_a^k i^k \&amp;= m \sum_{k=0}^a C_a^k \ \sum_{i=0}^{n-1} i^k m^i //交换枚举顺序 \&amp;= m \sum_{k=0}^a C_a^k \ f_{n-1,k} \&amp;= m \sum_{k=0}^a C_a^k \ (f_{n,k} - n^k m^n)\end{align}$$得到了$O(m^2)$ 的转移方程，完结撒花 好像 $O(m)$ 的要多项式插值和快速傅里叶变换求解，不会，不想填坑了 等等！完结不了，注意： 1、上式的 $k$ 有取到 $a$ 的情况，解个关于 $f_{n,i}$ 方程就好了 2、$f[0] = \sum_{i=0}^n m^i$ 等比数列，先一算，特判 $m=1$ 时不能用等比数列求和公式，直接 $ans = \sum_{i=1}^n i = \frac{n \times (n+1)}{2}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const ll p=1e9+7; const int N=1010; int n,m; ll f[N],Pow[N],C[N][N]; inline ll qpow(ll x,ll tim) &#123; ll ans=1; for(;tim;tim&gt;&gt;=1,x=x*x%p) if(tim&amp;1) ans=ans*x%p; return ans; &#125; #define Mod(x) (x)&gt;=p?(x)-p:(x) void init() &#123; C[0][0]=1; for(int i=1;i&lt;=m;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=m;j++) C[i][j]=Mod(C[i-1][j-1]+C[i-1][j]); &#125; Pow[0]=1; for(int i=1;i&lt;=m;i++) Pow[i]=Pow[i-1]*n%p; &#125; void work() &#123; scanf("%d%d",&amp;n,&amp;m); if(m==1) &#123; printf("%lld\n",(ll)(n+1)*n/2%p); return; &#125; init(); ll t1=qpow(m,n),t2=t1*m%p,inv=qpow(m-1,p-2); f[0]=(Mod(qpow(m,n+1)-1+p))*qpow(m-1,p-2)%p; for(int i=1;i&lt;=m;i++) &#123; ll sum=0; for(int j=0;j&lt;i;j++) sum=Mod(sum+(C[i][j]*(f[j]-Pow[j]*t1%p+p)%p)); if(m!=1) f[i]=(Pow[i]*t2-m*sum+p)%p*inv%p; &#125; printf("%lld\n",f[m]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错位排列 [数学]]]></title>
    <url>%2F2018%2F12%2F16%2F%C2%B4%C3%AD%C3%8E%C2%BB%C3%85%C3%85%C3%81%C3%90%2F</url>
    <content type="text"><![CDATA[写在前面那就先从一个例题引入吧 （来自《组合数学》P110） 题目在一次聚会上，有 $n$ 位男士和 $n$ 位女士。这 $n$ 位女士能够有多少种方法选择男舞伴开始第一支舞？如果在一首曲后每个人必须换舞伴，那么第二支舞又有多少种选择方法？ 分析首先，第一支舞有 $n!$ 中选择，而第二支舞的选择方法数为后面要讲的错位排序数 $D_n$ （说起来这个例子好像我校神犇兔崽子Tzz换女朋友） 错位排列首先安利 $Planet6174$ 的博客讲解 小学生都能看懂的错排问题解析 （高中生表示看懂了） 问题给定 $n$ 元集合 $X$，它的每一个元素都有一个特定的位置，而现在要求求出没有一个元素在它指定的位置上的排列的数目。（发现就是上面的第二支舞） 特别的，请注意，每一个元素都只有一个限定不能放的位置。 方法我们这里假定第 $i$ 个元素不能放在第 $i$ 个位置上（因为不一样的我们可以通过交换达成，对应顺序没有影响） 用 $D_n$ 表示 ${1,2,3,…n}$ 的错位排列的数目。那么，对于 $n=1$ ，不存在可行解； $n=2$ 时，唯一的错位排列是 2 1； $n=3$ 时有两个排列 2 3 1 和 3 1 2。因此，我们有 $D_1=0$， $D_2=1$， $D_3=2$。 递推式考虑将第 $n$ 个元素放到第 $k$ 个位置 $(k \neq n)$，有 $n-1$ 种放法，然后分类讨论 1、第 $k$ 个元素放到了第 $n$ 个位置上发现这样的话第 $n$ 个和第 $k$ 个就相当于不存在了，不影响其他元素的放置，此时，我们将其余的元素错位排列的方案数量有 $D_{n-2}$ 种 1、第 $k$ 个元素没有放到第 $n$ 个位置上这样相当于是加了一个限定：第 $k$ 个元素不能放在第 $n$ 个位置上。因为 $k$ 个位置已经被用过了，相当于不存在，那么可以说去掉了 $k$ 不放 $k$ 位的限制。这样我们可以交换第 $k$ 个和第 $n$ 个位置，就变成去掉了一个元素 $n$ 和位置 $k$ 的情况，即变成 $n-1$ 个元素的错位排列 $D_{n-1}$ 我们有了一个很简单的递推式$$ D_n = (n-1) \times (D_{n-2}+D_{n-1}) $$ 通项公式$$ D_n = n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} \cdots + (-1)^n \frac{1}{n!} \right)$$ 证明这个……详见《组合数学》P108 简单推一下，主要思想 容斥原理 首先，不考虑限制，总排列数为 $n!$ 。减掉不合法的：至少有一个元素放到它的指定位置的有 $C_n^1$ 种，限定了这个个的放法后，其余的 $n-1$ 个元素可以随意排列，共有 $C_n^1 \times (n-1)!$ 种。但这样有算重的，还要加上两个元素都放在它的指定位置上的方案数 $C_n^2 \times (n-2)!$ 种，再减去三个元素的……就得到了 $$\begin{aligned}D_n &amp;= n! - C_n^1 (n-1)! + C_n^2 (n-2)! \cdots (-1)^n C_n^n (n-n)! \&amp;= n! - \frac{n!}{1!(n-1)!} \times (n-1)! + \cdots + (-1)^n\frac{n!}{n!(n-n)!} \times (n-n)! \&amp;= n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} \cdots + (-1)^n \frac{1}{n!} \right) \\end{aligned}$$ 当然也可以 $$ D_n = \sum_{i=0}^n (-1)^n C_n^i (n-i)! $$ 参考资料1、$Planet6174$ 小学生都能看懂的错排问题解析2、《组合数学》第六章 容斥原理及应用-错位排序 完结撒花 你以为这就完了？不不不，上面那些并不是导致我写这篇博客的根本原因，源自一道题 限制了一些元素放置位置的错位排列题目Codeforces 340E 问题描述给你 $n$ 个球 $n$ 个盒子，一个盒子只能放一个球,限定第 $i$ 个球不能放在第 $i$ 个位置上，但已知一些盒子里面已经放了球，求一共有多少种合法的放置方案。 输入格式第一行一个整数表示 $n$ 。第二行 $n$ 个数 $a_i$ 。如果 $a_i = -1$ 表示第 $i$ 个盒子没有放球，否则表示第 $i$ 个盒子已经放了球 $a_i$ 。 输出格式一个非负整数表示合法的方案数，模 $1e9+7$ 。 样例输入125 -1 -1 2 1 -1 样例输出14 数据范围$$\begin{aligned}&amp;10\% \ \ \ 1 \leqslant n \leqslant 10 \&amp;50\% \ \ \ 1 \leqslant n \leqslant 2000 \&amp;100\% \ \ \ 1 \leqslant n \leqslant 2000000 \\end{aligned}$$ 分析真是，第一眼看到这个题目就想到了错排，但当时这是一个甚至没有列入学习计划的东西却认出来了，然后当场去学，发现错排好简单……再然后，被告知这个题还有放球的限制…… 突破口就是将球分成两部分：一个是没有限制可以随便放的，一个是有限制球 $i$ 不能放在盒子 $i$ 的 。其中已经放好了的球就不管了。 然后就有了一个 $O(n^2)$ 的 $dp$ ，记 $f[i][j]$ 为剩余 $i$ 个没限制的球和 $j$ 个有限制的球的方案数，然后你大力转移一下，就有了一个 $50$ 分的好成绩，再次完结撒花。 没有转移方程 -&gt; 因为在推 $dp$ 式敲代码的时候看了一眼原本的错位排列后突然想到了 $O(n)$ 的…… 容斥！ 不要管没有限制的球，我们记 $tot$ 为没有放好的球的个数，记 $a$ 为有限制的球的个数 。不理限制时，总共有 $tot \ !$ 种，然后再像上面一样，枚举至少有一个球 $i$ 放到盒子 $i$ ，其余随便排的 $C_a^i \times (tot-i)!$ 种减掉，再加上至少两个的……最后$$\begin{aligned}ans &amp;= tot! - C_a^1 (tot-1)! + C_a^2 (tot-2)! + \cdots + (-1)^a C_a^a (tot-a)! \&amp;= \sum_{i=0}^a (-1)^i C_a^i(tot-i)!\end{aligned}$$ 其实很简单（推式子用了一分钟，前面的一堆算上和机房的那群人聊天用了2h+—），好菜好菜…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define _ 0namespace TYC&#123; typedef long long ll; const int N=2e6+10; const int p=1000000007; const int inf=0x3f3f3f3f; int arr[N],vis[N]; ll fac[N],inv[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline ll qpow(ll x,ll tim) &#123; ll ans=1; for(;tim;tim&gt;&gt;=1,x=x*x%p) if(tim&amp;1) ans=ans*x%p; return ans; &#125; void init(const int n) &#123; fac[0]=1; for(int i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%p; inv[n]=qpow(fac[n],p-2); for(int i=n;i;i--) inv[i-1]=inv[i]*i%p; &#125; inline ll C(const int n,const int m) &#123; if(n&lt;m) return 0; return fac[n]*inv[m]%p*inv[n-m]%p; &#125; inline void work() &#123; int n=read(); int tot=0,x=0; for(int i=1;i&lt;=n;i++) &#123; arr[i]=read(); if(~arr[i]) vis[arr[i]]=1; else tot++; &#125; for(int i=1;i&lt;=n;i++) if(!vis[i]) x+=(arr[i]==-1); init(tot); ll ans=0; for(int i=0;i&lt;=x;i++) ans=(ans+(((i&amp;1)?-1:1)*C(x,i)+p)%p*fac[tot-i]%p)%p; printf("%lld\n",ans); &#125;&#125;int main()&#123; TYC::work(); return (0^_^0);&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
