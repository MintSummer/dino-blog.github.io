<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2019%2F05%2F02%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[用于解决子集异或等一类问题 什么是线性基 基：在线性代数中，基（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。 线性基是一种特殊的基，一般用于处理异或运算，它的意义是：通过原集合 $S$ 的某一个最小子集 $S1$ 使得 $S1$ 内元素相互异或得到的值域与原集合 $S$ 相互异或得到的值域相同。 （听说也叫最大线性无关组） 性质异或有一个性质：若 $a \oplus b = c$，则有 $a \oplus c = b$ 或 $b \oplus c = a$ 线性基能相互异或得到原集合的所有相互异或得到的值。 线性基是满足性质 $1$ 的最小的集合 对于同一序列，线性基里面的数的个数唯一 线性基中没有异或和为0的子集。 设序列 A 有 $n$ 个数插入线性基中，线性基的大小为 $|V|$，那么序列 A 的任意子集的异或值出现次数相同，均为 $2^{n - |V|}$ 插入我们用一个数组 $d$，表示序列 A 的线性基，下标 $i$ 表示 $2^i$ 那一维。 注意当数值大于 $2^{31} - 1$ 时，记得写成 1LL &lt;&lt; i 1234567891011inline void insert(int x) // 从可能的最高位开始&#123; for (int i = 30; ~i; i--) if (x &amp; (1 &lt;&lt; i)) &#123; if (!d[i]) return void(d[i] = x); else x ^= d[i]; &#125;&#125; 可以得到数组 $d$ 的性质：如果 $d[i]$ 不为 $0$，那么，$d[i]_{(2)}$ 的第 $i$ 位为 $1$，且 $d[i]_{(2)}$ 的最高位就是第 $i$ 位。 我们枚举序列中的数插入线性基中，对于当前这个数 $x$，分类讨论： 1、可以成功插入线性基中 设插入 $x$ 的位置为 $i$，它在插入的时可能异或了若干个数，那么 d[i] = x \oplus d[a] \oplus d[b] \oplus \cdots即 x = d[i] \oplus d[a] \oplus d[b] \oplus \cdots所以 $x$ 也由线性基中的若干个数异或得到 2、不能成功插入线性基中 不能插进去的时候就是 $x$ 异或了若干个数变成了 $0$，那么 x \oplus d[a] \oplus d[b] \oplus \cdots = 0即 x = d[a] \oplus d[b] \oplus \cdots所以 $x$ 不能成功插入线性基一定是因为此时线性基中已经可以有一些数的异或值为 $x$ 了，为了保证线性基最小，不插入 $x$。 根据这个插入的条件，我们可以发现，线性基中不存在 $d[a] \oplus d[b] \oplus \cdots = d[i]$ 的情况（否则 $d[i]$ 就不会插入了），所以线性基中没有异或值为 $0$ 的子集。 线性基合并合并两个线性基就是把一个线性基一位一位插入到另一个里面就行了，复杂度 $O(log^2n)$ 查询判断一个数是否能被序列 A 中的若干个数/当前线性基中的元素异或得到依照插入时的情况，直接将 $x$ 试着插入到线性基中，如果不能成功插入，那么说明当前线性基中已经有异或值为 $x$ 的子集了。 最大值给定序列 A，求从 A 中取出来若干个数的异或和的最大值 首先构造出这个序列的线性基，从最高为开始，贪心选取，如果当前 $ans$ 异或 $d[i]$ 可以变得更大，就异或 $d[i]$ 12345678inline int query_mx()&#123; int ans = 0; for (int i = 30; ~i; i--) if ((ans ^ d[i]) &gt; ans) ans ^= d[i]; return ans;&#125; 为啥呢？首先，优先使高位尽可能大，所以我们从高到低枚举。如果能变大就说明 $ans$ 的第 $i$ 位不为 $1$，直接异或，不考虑后面的，因为即便后面的能全变成 $1$，也不如 $i$ 这一位变成 $1$ 更大；如果不能变大就说明 $ans$ 的第 $i$ 位已经是 $1$ 了，变成 $0$ 肯定不优秀。 后面的不会对第 $i$ 位及更高位产生影响的，因为 $d[i]_{(2)}$ 的最高位为 $i$。 最小值给定序列 A，求从 A 中取出来若干个数的异或和的最小值 首先，别忘了，如果序列 A 中有未能成功插入线性基中的数，那么这个最小值一定为 $0$。 否则（线性基大小和原序列大小相同时）最小值就是 $min\{d[i]\}$（因为让最小值异或其他位一定会变大的，否则就不是最小值了）。 第 $k$ 小值给定序列 A，求从 A 中取出来若干个数的异或和的第 $k$ 小。（例题 HDU3949 ） 原谅我……说不清楚……口胡了一堆……还是看代码吧…… 我们要对这个线性基处理一下：对于每一个 $d[i]$，从高向低枚举前 $i - 1$ 位($j$ 从 $i - 1$ 到 $0$），若 $d[i]_{(2)}$ 的第 $j$ 位为 $1$，则令 $d[i] = d[i] \oplus d[j]$。 这样处理完后得到的 $d$ 满足只有 $d[i]$ 的第 $i$ 位为 $1$，其余均为 $0$。 然后如果 $k_{(2)}$ 的第 $i$ 位为 $1$ 时 $ans = ans \oplus d[i]$ 即可 1234567891011121314151617181920212223inline void init()&#123; for (int i = 0; i &lt;= 60; i++) for (int j = 0; j &lt; i; j++) if (d[i] &amp; (1LL &lt;&lt; j)) d[i] ^= d[j]; tot = 0; for (int i = 0; i &lt;= 60; i++) if (d[i]) d[tot++] = d[i];&#125;inline ll query_k(ll k)&#123; k -= (n != tot); // 去掉异或值为0的情况 if (k &gt;= (1LL &lt;&lt; tot)) // 不存在第k小 return -1; ll ans = 0; for (int i = 0; i &lt; tot; i++) if (k &amp; (1LL &lt;&lt; i)) ans ^= d[i]; return ans;&#125; 求一个数在序列 A 取若干个数异或值的集合中的排名注意，这里是集合，不考虑一个异或值有多少种方法能异或得到（好吧这个次数就是 $2^{n - |V|}$），算具体排名的可以看bzoj2844 albus就是要第一个出场） 根据 $x$ 的二进制位，从低位到高位，若 $x$ 的第 $i$ 位为 $1$，那么就有 $2^{cnt}$ （$cnt$ 为前 $i - 1$ 位中线性基的大小）中比 $x$ 小的异或值，最后别忘了 $+1$ 得到 $x$ 的排名 123456789101112inline int query_rank(const int x)&#123; int rk = 0, t = 1; for (int i = 0; i &lt;= 30; i++) if (d[i]) &#123; if (x &amp; (1 &lt;&lt; i)) rk += t; t &lt;&lt;= 1; &#125; return rk + 1;&#125; 例题bzoj2460 [BeiJing2011]元素 bzoj2115 [Wc2011] Xor bzoj2844 albus就是要第一个出场 bzoj4568 [Scoi2016]幸运数字 参考资料a_forever_dream-线性基详解 百度百科-线性基 ljh2000-关于线性基的学习与理解]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速沃尔什变换 FWT]]></title>
    <url>%2F2019%2F03%2F28%2FFWT%2F</url>
    <content type="text"><![CDATA[非常感谢给我讲了这个做法的神仙跳瓜，祝愿他在即将到来的 CTS2019 中以 AK 的好成绩成功进国家队！ 问题给你两个向量 $A, B$，和一个 $k$ 进制运算 $\circ$ 求 一个向量 $C$ 满足 C_{i \circ j} = \sum A_i B_j方法这里只考虑 $k=2$ 的情况（ $k$ 更大的参考 loj548「LibreOJ β Round #7」某少女附中的体育课 以及 LCA 的题解，我还没看呐） 。 我们现在要得到一个转换 $F$ 使得 $F(A * B) = F(A) \cdot F(B)$ 分治，分成 $2$ 段，对于当前 $A$ 要得到 $B_0$ 和 $B_1$ 使得 $F(A) = (F(B_0), F(B_1))$ 。 $A_0$，$A_1$ 是前 $\frac{n}{2}$ 项和后 $\frac{n}{2}$ 项（已经通过分治求出，$n$ 补成 $2$ 的幂）。 构造一个 $2 \times 2$ 的矩阵 $T$，使得 B_0 = T_{0, 0} A_0 + T_{0, 1} A_1 \\ B_1 = T_{1, 0} A_0 + T_{1, 1} A_1即 T \left[ \begin{matrix} A_0 \\ A_1 \end{matrix} \right] = \left[ \begin{matrix} B_0 \\ B_1 \end{matrix} \right]其中 $T_0$，$T_1$ 是方程 $x_i \cdot x_j = x_{i \circ j}$ 的两组解，要求这两组解线性无关（不知道的戳线性相关） 以 $xor$ 为例，$x_i \cdot x_j = x_{i \oplus j}$ 即 \begin{cases} x_0 \cdot x_0 = x_0 \\ x_0 \cdot x_1 = x_1 \\ x_1 \cdot x_1 = x_0 \end{cases}解得 \begin{cases} x_0 = 1 \\ x_1 = 1 \end{cases} \ \ \ \ \ \begin{cases} x_0 = 1 \\ x_1 = -1 \end{cases}那么就有 T = \left[ \begin{matrix} 1 & 1 \\ 1 & -1 \\ \end{matrix} \right]所以 B_0 = A_0 + A_1 \\ B_1 = A_0 - A_1然后就可以得到 $F(A)$ 了。 IFWT 就是已知 $B$ 求 $A$，解上面的二元一次方程组即可 A_0 = \frac{B_0 + B_1}{2} \\ A_1 = \frac{B_0 - B_1}{2}跳瓜说这个东西的顺序没有影响（所以貌似你怎么弄都行） 模板Luogu4717【模板】快速沃尔什变换 为了将这三个分块写所以写的很冗杂（但是可以直接用一块） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 17 | 5; const int p = 998244353; namespace Or &#123; void FWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = x; a[i + len + k] = (x + y) % p; &#125; &#125; void IFWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = x; a[i + len + k] = (y - x + p) % p; &#125; &#125; inline void Mul(const int *A, const int *B, int *c, const int n) &#123; static int a[N], b[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); FWT(a, n), FWT(b, n); for (int i = 0; i &lt; n; i++) c[i] = int((ll)a[i] * b[i] % p); IFWT(c, n); &#125; &#125; namespace And &#123; void FWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x + y) % p; a[i + len + k] = y; &#125; &#125; void IFWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x - y + p) % p; a[i + len + k] = y; &#125; &#125; inline void Mul(const int *A, const int *B, int *c, const int n) &#123; static int a[N], b[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); FWT(a, n), FWT(b, n); for (int i = 0; i &lt; n; i++) c[i] = int((ll)a[i] * b[i] % p); IFWT(c, n); &#125; &#125; namespace Xor &#123; const int INV2 = (p + 1) &gt;&gt; 1; void FWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; &#125; void IFWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = int((ll)(x + y) * INV2 % p); a[i + len + k] = int((ll)(x - y + p) * INV2 % p); &#125; &#125; inline void Mul(const int *A, const int *B, int *c, const int n) &#123; static int a[N], b[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); FWT(a, n), FWT(b, n); for (int i = 0; i &lt; n; i++) c[i] = int((ll)a[i] * b[i] % p); IFWT(c, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; static int a[N], b[N], c[N]; int n = 1 &lt;&lt; read(); for (int i = 0; i &lt; n; i++) a[i] = read(); for (int i = 0; i &lt; n; i++) b[i] = read(); Or::Mul(a, b, c, n); for (int i = 0; i &lt; n; i++) printf("%d ", c[i]); puts(""); And::Mul(a, b, c, n); for (int i = 0; i &lt; n; i++) printf("%d ", c[i]); puts(""); Xor::Mul(a, b, c, n); for (int i = 0; i &lt; n; i++) printf("%d ", c[i]); puts(""); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>向量</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以前写的嘴子 FWT 讲解]]></title>
    <url>%2F2019%2F03%2F28%2FFWT_old%2F</url>
    <content type="text"><![CDATA[还是不要看这个了……这是嘴子玩意…… 问题给你两个向量 $A, B$ 求 C_{i\&j} = \sum A_i \times B_j\\ C_{i|j} = \sum A_i \times B_j\\ C_{i \oplus j} = \sum A_i \times B_j\\($\oplus$ 是异或) 方法FWT 用于处理向量的位运算卷积 考虑一下 $FFT$ 的过程，就是将系数表达式变成点值表达式，点值相乘后再将点值表达式变成系数表达式。 FWT 可以同样用这个过程，先用 FWT 转换，再利用 $FWT(C) = FWT(A) \times FWT(B)$ （对应项相乘），然后转回去。 主要思想还是 分治。 or 或卷积求 $C_{i | j} = \sum A_i B_j$ 首先，对于 $or$ 卷积而言 $FWT(A)[i] = \sum_{j | i = i} A[j]$，就是它在或意义下的子集 我们记 $A_0$ 为 $A$ 的前 $2^{n - 1}$ 项（一半），$A_1$ 为 $A$ 的后 $2^{n - 1}$ 项（记最高项为 $0$ 的归 $A_0$， 为 $1$ 归 $A_1$），假定我们已经知道了 $FWT(A_0)$ 和 $FWT(A_1)$，现在要求 $FWT(A)$ 当 $n = 0$ 时，$FWT(A) = A$ $FWT(A)$ 的前一半首位填 $0$，那么它的子集还是 $FWT(A_0)$ $FWT(A)$ 的后一半首位填 $1$，那么它的子集是 $FWT(A_0 + A_1)$ 前一半只会有 $A_0$ 有贡献，所以就是 $A_0$ 因为 $A_0$ 和 $A_1$ 做 $or$ 卷积时，首位被 $or$ 成 $1$，只会贡献到 $A$ 的后一半，所以后一半应当是 $A_0 + A_1$ 好吧，我承认自己说的奇奇怪怪的，安利博客， 博客里面大佬说（证）了： FWT(A + B) = FWT(A) + FWT(B) 总结下来就是 FWT(A) = \begin{cases} (FWT(A_0), FWT(A_0) + FWT(A_1)) & n > 0 \\ A & n = 0 \\ \end{cases}$(,)$ 表示两段接起来 然后就可以愉快地得到 $FWT(A)$ 了。大佬还证明了 $FWT(A|B) = FWT(A) \times FWT(B)$ 然而我懒得写了。 然后再考虑转回去，倒着做 记 $A_0’$，$A_1’$ 分别为 $A$ 的前一半后一半，则 $A_0’ = A_0$，$A_1’ = A_0 + A_1$，那么 \begin{aligned} A_0 &= A_0' \\ A_1 &= A_1' - A_0'\\ \end{aligned} \Rightarrow IFWT(A) = (IFWT(A_0), IFWT(A_1) - IFWT(A_0))代码12345678910111213141516171819202122void FWT(int *a, const int n)&#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = x; a[i + len + k] = (x + y) % p; &#125;&#125;void IFWT(int *a, const int n)&#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = x; a[i + len + k] = (y - x + p) % p; &#125;&#125; and 与卷积求 $C_{i \&amp; j} = \sum A_i B_j$ 因为 $FWT(A)[i] = \sum_{j \&amp; i = i} A[j]$ ，所以 FWT(A) = \begin{cases} (FWT(A_0) + FWT(A_1)， FWT(A_1)) & n > 0 \\ A & n = 0 \\ \end{cases}$IFWT$ 的时候 \begin{aligned} A_0 &= A_0' - A_1' \\ A_1 &= A_1'\\ \end{aligned} \Rightarrow IFWT(A) = (IFWT(A_0) - IFWT(A_1), IFWT(A_1))代码12345678910111213141516171819202122void FWT(int *a, const int n)&#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x + y) % p; a[i + len + k] = y; &#125;&#125;void IFWT(int *a, const int n)&#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x - y + p) % p; a[i + len + k] = y; &#125;&#125; xor 异或卷积求 $C_{i \oplus j} = \sum A_i B_j$ 因为 $FWT(A)[i] = \sum_{j \oplus i = i} A[j]$ ，所以 FWT(A) = \begin{cases} (FWT(A_0) + FWT(A_1)， FWT(A_0) - FWT(A_1)) & n > 0 \\ A & n = 0 \\ \end{cases}$IFWT$ 的时候 \begin{aligned} A_0 &= \frac{A_0' + A_1'}{2} \\ A_1 &= \frac{A_0' - A_1'}{2}\\ \end{aligned} \Rightarrow IFWT(A) = (\frac{IFWT(A_0) + IFWT(A_1)}{2}, \frac{IFWT(A_0) - IFWT(A_1)}{2})代码1234567891011121314151617181920212223const int INV2 = (p + 1) &gt;&gt; 1;void FWT(int *a, const int n)&#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125;&#125;void IFWT(int *a, const int n)&#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = int((ll)(x + y) * INV2 % p); a[i + len + k] = int((ll)(x - y + p) * INV2 % p); &#125;&#125; 总感觉这个没啥理由打上数学的标签 模板Luogu4717【模板】快速沃尔什变换 为了将这三个分块写所以写的很冗杂（但是可以直接用一块） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 17 | 5; const int p = 998244353; namespace Or &#123; void FWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = x; a[i + len + k] = (x + y) % p; &#125; &#125; void IFWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = x; a[i + len + k] = (y - x + p) % p; &#125; &#125; inline void Mul(const int *A, const int *B, int *c, const int n) &#123; static int a[N], b[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); FWT(a, n), FWT(b, n); for (int i = 0; i &lt; n; i++) c[i] = int((ll)a[i] * b[i] % p); IFWT(c, n); &#125; &#125; namespace And &#123; void FWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x + y) % p; a[i + len + k] = y; &#125; &#125; void IFWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x - y + p) % p; a[i + len + k] = y; &#125; &#125; inline void Mul(const int *A, const int *B, int *c, const int n) &#123; static int a[N], b[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); FWT(a, n), FWT(b, n); for (int i = 0; i &lt; n; i++) c[i] = int((ll)a[i] * b[i] % p); IFWT(c, n); &#125; &#125; namespace Xor &#123; const int INV2 = (p + 1) &gt;&gt; 1; void FWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; &#125; void IFWT(int *a, const int n) &#123; for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = a[i + len + k]; a[i + k] = int((ll)(x + y) * INV2 % p); a[i + len + k] = int((ll)(x - y + p) * INV2 % p); &#125; &#125; inline void Mul(const int *A, const int *B, int *c, const int n) &#123; static int a[N], b[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); FWT(a, n), FWT(b, n); for (int i = 0; i &lt; n; i++) c[i] = int((ll)a[i] * b[i] % p); IFWT(c, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; static int a[N], b[N], c[N]; int n = 1 &lt;&lt; read(); for (int i = 0; i &lt; n; i++) a[i] = read(); for (int i = 0; i &lt; n; i++) b[i] = read(); Or::Mul(a, b, c, n); for (int i = 0; i &lt; n; i++) printf("%d ", c[i]); puts(""); And::Mul(a, b, c, n); for (int i = 0; i &lt; n; i++) printf("%d ", c[i]); puts(""); Xor::Mul(a, b, c, n); for (int i = 0; i &lt; n; i++) printf("%d ", c[i]); puts(""); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 参考资料大佬yyb https://www.cnblogs.com/cjyyb/p/9065615.htmlACMLCZH https://www.cnblogs.com/ACMLCZH/p/8022502.html]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>向量</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3625 小朋友和二叉树 [多项式]]]></title>
    <url>%2F2019%2F03%2F21%2Fbzoj3625%2F</url>
    <content type="text"><![CDATA[题目bzoj3625 我们的小朋友很喜欢计算机科学，而且尤其喜欢二叉树。考虑一个含有 $n$ 个互异正整数的序列 $c_1,c_2,\cdots,c_n$。如果一棵带点权的有根二叉树满足其所有顶点的权值都在集合 $\{c_1,c_2,…,c_n\}$ 中，我们的小朋友就会将其称作神犇的。并且他认为，一棵带点权的树的权值，是其所有顶点权值的总和。 给出一个整数 $m$，你能对于任意的 $s(1 \leqslant s \leqslant m)$ 计算出权值为 $s$ 的神犇二叉树的个数吗？请参照样例以更好的理解什么样的两棵二叉树会被视为不同的。 我们只需要知道答案关于 $998244353$ 取模后的值。 第一行有2个整数 $n,m(1 \leqslant n \leqslant 10^5, 1 \leqslant m \leqslant 10^5)$。 第二行有 $n$ 个用空格隔开的互异的整数 $c[1],c[2],\cdots,c[n]（1 \leqslant c[i] \leqslant 10^5)$。 输出m行，每行有一个整数。第i行应当含有权值恰为i的神犇二叉树的总数。 题中所说的样例 Input122 31 2 Output123139 分析想了很久才发现没有点数的限制……根本不知道二维怎么优化…… 记 $f_i$ 为权值为 $i$ 时的答案（二叉树个数） f_0 = 1 \\ f_s = \sum_{i = 1}^n \sum_{j = 0}^{s - c_i} f_j f_{s - c_i - j}这个枚举 $c_i$ 好烦啊，你看后面的那两个很像卷积，甚至看上去(很希望)能和 $c_i$ 一起卷起来 那么就记 $v_i$ 表示 $i$ 这个数是否在 $c_i$ 的集合中出现过，就变成 f_s = \sum_{i = 0}^m v_i \sum_{j = 0}^{s - i} f_j f_{s - i - j}我们记 $V(x)$ 为 $v_i$ 的生成函数 $V(x) = \sum_{i = 0}^n v_ix^i$，记 $F(x)$ 为 $f_i$ 的生成函数，然后就可以卷起来 F = V * F * F + 1求 $F$ 直接上二次函数求根公式 F = \frac{1 \pm \sqrt{1 - 4V}}{2V}又到了（初中时候就很烦的）二次函数根的舍去问题，这里一定要注意常数项 $F_0 = 1$， $C_0 = 0$ F = \frac{1 + \sqrt{1 - 4V}}{2V} \tag{1}要舍去（原因安利博客 https://blog.csdn.net/ez_tjy/article/details/81137100） 对于 F = \frac{1 - \sqrt{1 - 4V}}{2V} \tag{2}因为 $V_0 = 0$，不能作为分母，构造一个 $1 + \sqrt{1 - 4V}$ 分子分母同时乘上，则 \begin{aligned} F &= \frac{1^2 - (\sqrt{1 - 4V})^2}{2V (1 + \sqrt{1 - 4V})} \\ &= \frac{1 - 1 + 4V}{2V (1 + \sqrt{1 - 4V})} \\ &= \frac{2}{1 + \sqrt{1 - 4V}} \\ \end{aligned}上多项式开根和求逆就行了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 18 | 5; const int p = 998244353; const int INV2 = (p + 1) &gt;&gt; 1; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(3, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void Mul(const int *A, const int *B, int *c, const int n) &#123; static int len, a[N], b[N]; for (len = 1; len &lt;= (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + n, 0, sizeof(int[len - n])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + n, 0, sizeof(int[len - n])); &#125; void _inv(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; _inv(A, b, t); static int len, a[N]; for (len = 1; len &lt;= (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] % p - (ll)a[i] * b[i] % p * b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void Inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); memset(b, 0, sizeof(int[n])); _inv(a, b, n); &#125; void _sqrt(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = 1; else &#123; int t = (n + 1) &gt;&gt; 1; _sqrt(A, b, t); static int len, inv[N], a[N]; for (len = 1; len &lt;= (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); Inv(b, inv, n); Mul(a, inv, a, n); for (int i = 0; i &lt; n; i++) b[i] = int((ll)(b[i] + a[i]) * INV2 % p); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void Sqrt(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); memset(b, 0, sizeof(int[n])); _sqrt(a, b, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; int n = read(), m = read() + 1; static int a[N], tmp[N]; for (int i = 1; i &lt;= n; i++) a[read()] = p - 4; a[0] = 1; Poly::Sqrt(a, tmp, m); (tmp[0] += 1) %= p; Poly::Inv(tmp, tmp, m); for (int i = 1; i &lt; m; i++) printf("%d\n", int(2LL * tmp[i] % p)); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式开根]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BC%80%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[先插一个 多项式快速幂问题Luogu5245 多项式快速幂 给定一个多项式 $A(x)$，求 $B(x)$ 使得 $B(x) \equiv A^k(x) \mod x^n$ 方法相当于是 \log_{A(x)} B(x) = k换底 \frac{\ln(B(x))}{\ln(A(x))} = k \\ \ln(B(x)) = k\ln(A(x))求出来 $\ln(A(x))$ 后系数乘上 $k$ 再 $\exp$ 回去就行了 赶紧回来 问题Luogu5205 多项式开根 给定一个 $n-1$ 次多项式 $A(x)$ ，求一个在 $\bmod\ x^n$ 意义下的多项式 $B(x)$ ，使得 $B^2(x) \equiv A(x) \ \mod\ x^n$多项式的系数在 $\bmod 998244353$ 的意义下进行运算。 方法方法一： 欸，这个开根不就是指数为 $\frac{1}{2}$ 的情况嘛，直接 $\ln + \exp$ 搞定 方法二： 不行，$\ln + \exp$ 太麻烦了，我要推式子！ 令 $C(x) \equiv B(x) \mod x^{\lceil\frac{n}{2}\rceil}$ ，即 $C(x) - B(x) \equiv 0 \mod x^{\lceil\frac{n}{2}\rceil} \\$ 两边同时平方（模数也平方） (C(x) - B(x))^2 \equiv 0 \mod x^n \\ C^2(x) - 2 C(x) B(x) + B^2(x) \equiv 0 \mod x^n \\根据 $B^2(x) \equiv A(x) \ mod\ x^n$ C^2(x) - 2 C(x) B(x) + A(x) \equiv 0 \mod x^nB(x) \equiv \frac{C^2(x) + A(x)}{2 C(x)} \mod x^n \tag{1} B(x) \equiv \frac{C(x) + A(x) * inv(C(x))}{2} \mod x^n \tag{2}你发现 得到 $C(x)$ 就可以求 $B(x)$ 了，递归处理。这下就只用求逆了。 至于 $(1)$ 和 $(2)$，你发现 $(1)$ 要算两次乘法一次求逆，但是 $(2)$ 只用一次乘法一次求逆就行了，虽然我常数大但是还是要注重效率嘛 代码快速幂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int p = 998244353; const int INV2 = (p + 1) &gt;&gt; 1; const int N = 1 &lt;&lt; 18 | 5; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(3, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void Mul(const int *A, const int *B, int *c, const int n) &#123; static int len, a[N], b[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + n, 0, sizeof(int[len - n])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + n, 0, sizeof(int[len - n])); &#125; void _Inv(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; _Inv(A, b, t); static int len, a[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] % p - (ll)a[i] * b[i] % p * b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void Inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _Inv(a, b, n); &#125; inline void Diff(const int *A, int *b, const int n) &#123; for (int i = 1; i &lt; n; i++) b[i - 1] = int((ll)A[i] * i % p); b[n - 1] = 0; &#125; inline void Inte(const int *A, int *b, const int n) &#123; static int inv[N]; inv[1] = 1; for (int i = 2; i &lt; n; i++) inv[i] = int((ll)inv[p % i] * (p - p / i) % p); for (int i = n - 1; i &gt;= 0; i--) b[i + 1] = int((ll)A[i] * inv[i + 1] % p); b[0] = 0; &#125; inline void Ln(const int *A, int *b, const int n) &#123; static int da[N], inva[N]; Diff(A, da, n), Inv(A, inva, n); Mul(da, inva, b, n); Inte(b, b, n); &#125; void _Exp(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = 1; else &#123; int t = (n + 1) &gt;&gt; 1; _Exp(A, b, t); static int tmp[N]; Ln(b, tmp, n); for (int i = 0; i &lt; n; i++) tmp[i] = (-tmp[i] + A[i] + p) % p; tmp[0] = (tmp[0] + 1) % p; Mul(tmp, b, b, n); &#125; &#125; inline void Exp(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _Exp(a, b, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; int n = read(); static int a[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); Poly::Ln(a, a, n); for (int i = 0; i &lt; n; i++) a[i] = int((ll)a[i] * INV2 % p); Poly::Exp(a, a, n); for (int i = 0; i &lt; n; i++) printf("%d ", a[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 求逆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 18 | 5; const int p = 998244353; const int INV2 = (p + 1) &gt;&gt; 1; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(3, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void Mul(const int *A, const int *B, int *c, const int n) &#123; static int len, a[N], b[N]; for (len = 1; len &lt;= n &lt;&lt; 1; len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + n, 0, sizeof(int[len - n])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + n, 0, sizeof(int[len - n])); &#125; void _Inv(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; _Inv(A, b, t); static int len, a[N]; for (len = 1; len &lt;= n &lt;&lt; 1; len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] % p - (ll)a[i] * b[i] % p * b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void Inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _Inv(a, b, n); &#125; void _Sqrt(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = 1; else &#123; int t = (n + 1) &gt;&gt; 1; _Sqrt(A, b, t); static int len, inv[N], a[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); Inv(b, inv, n); Mul(inv, a, a, n); for (int i = 0; i &lt; n; i++) b[i] = int((ll)(b[i] + a[i]) % p * INV2 % p); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void Sqrt(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); memset(b, 0, sizeof(int[n])); _Sqrt(a, b, n); &#125; &#125; void work() &#123; int n = read(); static int a[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); Poly::Sqrt(a, a, n); for (int i = 0; i &lt; n; i++) printf("%d ", a[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 上面是求逆，下面是快速幂（没开 $O2$ ，我怎么跑这么慢人形大常数）]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治FFT [分治] [多项式]]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%88%86%E6%B2%BBFFT%2F</url>
    <content type="text"><![CDATA[被名字骗了……说白了就是分治加 $FFT$（两者完全就是分开的啊） 题目模板 Luogu4721 分治 FFT 给定长度为 $n-1$ 的数组 $g[1],g[2],\cdots,g[n-1]$，求 $f[0],f[1],\cdots,f[n-1]$，其中 f[i]=\sum_{j=1}^if[i-j]g[j]边界为 $f[0]=1$ 。系数模 $998244353$ 。 分析方法一：多项式求逆emmmmm这不是显然多项式求逆啊…… f = f * g + 1 = \frac{1}{1 - g}然后直接求逆吧，时间复杂度 $O(n log n)$ 方法二：分治+多项式有点像 $CDQ$ 分治的思想：先递归处理 $[l, mid]$ 的 $f$，然后再算 $[l, mid]$ 对 $(mid, r]$ 的贡献，再递归处理 $(mid, r]$ 的 $f$ 贡献就是 $(mid, r]$ （分别）加上 $f[l,mid] * g[0, r - l + 1]$ 卷出来 $(mid - l, r - l]$ 项。 （说的混乱不清……可以安利机房大佬 zyt 的博客 [洛谷4721][模板]分治FFT(CDQ分治_NTT) 时间复杂度 $O(n log^2 n)$ 代码求逆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 18 | 5; const int p = 998244353; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(3, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void mul(const int *A, const int *B, int *c, const int n) &#123; static int len, a[N], b[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); memset(a + n, 0, sizeof(int[n])); memset(b + n, 0, sizeof(int[n])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + (n &lt;&lt; 1), 0, sizeof(int[len - (n &lt;&lt; 1)])); &#125; void _inv(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; _inv(A, b, t); static int len, a[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] - (ll)a[i] * b[i] % p *b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _inv(a, b, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; int n = read(); static int arr[N], ans[N]; arr[0] = 1; for (int i = 1; i &lt; n; i++) arr[i] = p - read(); Poly::inv(arr, ans, n); for (int i = 0; i &lt; n; i++) printf("%d ", ans[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 分治 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 18 | 5; const int p = 998244353; int arr[N], ans[N]; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(3, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void Mul(const int *A, const int *B, int *c, const int n, const int m) &#123; static int len, a[N], b[N]; for (len = 1; len &lt; (n + m); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[m])); memset(a + n, 0, sizeof(int[len - n])); memset(b + m, 0, sizeof(int[len - m])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + n + m, 0, sizeof(int[len - (n + m)])); &#125; &#125; void solve(const int l, const int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; solve(l, mid); static int tmp[N]; Poly::Mul(ans + l, arr, tmp, mid - l + 1, r - l + 1); for (int i = mid + 1; i &lt;= r; i++) ans[i] = (ans[i] + tmp[i - l]) % p; solve(mid + 1, r); &#125; void work() &#123; int n = read(); for (int i = 1; i &lt; n; i++) arr[i] = read(); ans[0] = 1; solve(0, n - 1); for (int i = 0; i &lt; n; i++) printf("%d ", ans[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 可以看一下时间对比 (开了 $O2$)]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式指数函数 exp]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[问题给出 $n$ 次多项式 $A(x)$，求一个多项式 $B(x)$，满足 $B(x) \equiv e^{A(x)} \mod x^{n + 1}$。 保证 $a_0 = 0$ 方法前置芝士有点多，不会讲的特别清楚了 牛顿迭代百度百科-牛顿迭代法讲的也挺好的，或者你也可以找一个神仙给你全部讲清楚像我一样 求解 $f(x) = 0$ 的根 $r$。从初始近似值开始不断迭代，其中 $r$ 的第 $n + 1$ 次近似值为： x_{n + 1} = x_n - \frac{f(x_n)}{f'(x_n)} 已经证明，如果是连续的，并且待求的零点是孤立的，那么在零点周围存在一个区域，只要初始值位于这个邻近区域内，那么牛顿法必定收敛。 并且，如果不为0, 那么牛顿法将具有平方收敛的性能. 粗略的说，这意味着每迭代一次，牛顿法结果的有效数字将增加一倍。 ——《百度百科》 (对于多项式而言就是从 $\operatorname{mod} x^{\lceil\frac{n}{2}\rceil}$ 变成了 $\operatorname{mod} x^n$) 实际上现在只要知道这个迭代公式就行了 泰勒展开还是先推送 百度百科-泰勒公式 甚至公式都直接是百度百科上的 把 $A_0(x)$ 带入 $x_0$ 来得到 $A(x)$，因为 $A(x)$ 是模 $x^n$ 意义下的结果，而 $A_0(x)$ 是 $A(x) \mod x^{\lceil\frac{n}{2}\rceil}$ 那么 $A(x) - A_0(x)$ 的后 $x^{\lceil\frac{n}{2}\rceil}$ 都是 $0$，所以 $(A(x) - A_0(x))^2 \mod x^n \equiv 0$ 那么后面的二阶到 $n$ 阶都没了，神仙给我展开后就是 A(x) = A_0(x) - \frac{f(A_0(x))}{f'(A_0(x))}得到牛顿迭代对于多项式同样可行。 回到原题求一个 $B(x)$ 使得 $B(x) \equiv \mathrm{e}^{A(x)} \mod x^{n + 1}$，即 \ln(B(x)) \equiv A(x) \mod x^{n + 1}\ln(B(x)) - A(x) \equiv 0 \mod x^{n + 1}现在就是要求函数 $F(B(x)) = \ln(B(x)) - A(x)$ 的零点（自变量是 $B(x)$， $A(x)$ 是常数），它的导数是 $F’(B(x)) = \frac{1}{B(x)}$ （导数后常数项就没了） 牛顿迭代 \begin{aligned} B(x) \leftarrow & B(x) - \frac{F(B(x))}{F'(B(x))} \\ & B(x) - (\ln(B(x)) - A(x))B(x) \\ & B(x)(-\ln(B(x)) + A(x) + 1) \\ \end{aligned}然后就可以迭代了，每迭代一次长度翻倍（$n = 0$ 时 $b_0 = 1$） 代码模板 Luogu4726 多项式指数函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int p = 998244353; const int g = 3; const int N = 1 &lt;&lt; 18 | 5; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(g, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; inline void Plus(const int *a, const int *b, int *c, const int n) &#123; for (int i = 0; i &lt; n; i++) c[i] = (a[i] + b[i]) % p; &#125; inline void Minus(const int *a, const int *b, int *c, const int n) &#123; for (int i = 0; i &lt; n; i++) c[i] = (a[i] - b[i] + p) % p; &#125; void Mul(const int *A, const int *B, int *c, const int n) &#123; static int len, a[N], b[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + n, 0, sizeof(int[len - n])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + n, 0, sizeof(int[len - n])); &#125; void _Inv(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; _Inv(A, b, t); static int len, a[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] - (ll)a[i] * b[i] % p * b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void Inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _Inv(a, b, n); &#125; inline void Diff(const int *a, int *b, const int n) &#123; for (int i = 1; i &lt; n; i++) b[i - 1] = int((ll)a[i] * i % p); b[n - 1] = 0; &#125; inline void Inte(const int *a, int *b, const int n) &#123; static int inv[N]; inv[1] = 1; for (int i = 2; i &lt; n; i++) inv[i] = int((ll)inv[p % i] * (p - p / i) % p); for (int i = n - 1; i &gt;= 0; i--) b[i + 1] = int((ll)a[i] * inv[i + 1] % p); b[0] = 0; &#125; inline void Ln(const int *a, int *b, const int n) &#123; static int da[N], inva[N]; Inv(a, inva, n); Diff(a, da, n); Mul(inva, da, b, n); Inte(b, b, n); &#125; void _Exp(const int *a, int *b, const int n) &#123; if (n == 1) b[0] = 1; else &#123; int t = (n + 1) &gt;&gt; 1; _Exp(a, b, t); static int tmp[N]; Ln(b, tmp, n); for (int i = 0; i &lt; n; i++) tmp[i] = (-tmp[i] + a[i] + p) % p; tmp[0] = (tmp[0] + 1) % p; Mul(b, tmp, b, n); &#125; &#125; inline void Exp(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _Exp(a, b, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; int n = read(); static int a[N], b[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); Poly::Exp(a, b, n); for (int i = 0; i &lt; n; i++) printf("%d ", b[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式对数函数 ln]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%A4%9A%E9%A1%B9%E5%BC%8Fln%2F</url>
    <content type="text"><![CDATA[问题给出 $n$ 次多项式 $A(x)$，求一个多项式 $B(x)$，满足 $B(x) \equiv \ln A(x) \mod x^{n + 1}$。 保证 $a_0 = 1$ 方法前置芝士最基本的微积分 $f(x) = x^k$ 的导数是 $f’(x) = kx^{k - 1}$ 和的导数等于导数的和 显然 $A(x)$ 的导数是 $A’(x) = \sum_{i = 1}^n a_i i x^{i - 1}$ 123456inline void derivative(const int *a, int *b, const int n)&#123; for (int i = 1; i &lt; n; i++) b[i - 1] = int((ll)a[i] * i % p); b[n - 1] = 0;&#125; 同时可以得到 $A(x)$ 的积分 $\int A(x) \mathrm{d}x = \sum_{i = 1}^n \frac{a_{i - 1}}{i} x^i$ 1234567891011inline void integral(const int *a, int *b, const int n)&#123; static int inv[N]; inv[1] = 1; for (int i = 2; i &lt; n; i++) inv[i] = int((ll)inv[p % i] * (p - p / i) % p); for (int i = n - 1; i &gt;= 0; i--) b[i + 1] = int((ll)a[i] * inv[i + 1] % p); b[0] = 0;&#125; 链式法则：$f(g(x))$ 的导数是 $f’(g(x)) g’(x)$ $f(x) = \ln(x)$ 的导数是 $f’(x) = \frac{1}{x}$。 回到原题对 $B(x) = ln(A(x))$ 两边同时求导 B'(x) = \frac{1}{A(x)} A'(x) = \frac{A'(x)}{A(x)}求个 $A(x)$ 的逆元（多项式求逆）然后乘上 $A’(x)$，最后把 $B’(x)$ 积分回去就好了。 代码模板 Luogu4725 多项式对数函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int p = 998244353; const int g = 3; const int N = 1 &lt;&lt; 18 | 5; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(g, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void Mul(const int *A, const int *B, int *c, const int n) &#123; static int len, a[N], b[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + n, 0, sizeof(int[len - n])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + n, 0, sizeof(int[len - n])); &#125; void _Inv(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; _Inv(A, b, t); static int len, a[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] - (ll)a[i] * b[i] % p * b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void Inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _Inv(a, b, n); &#125; inline void Diff(const int *a, int *b, const int n) &#123; for (int i = 1; i &lt; n; i++) b[i - 1] = int((ll)a[i] * i % p); b[n - 1] = 0; &#125; inline void Inte(const int *a, int *b, const int n) &#123; static int inv[N]; inv[1] = 1; for (int i = 2; i &lt; n; i++) inv[i] = int((ll)inv[p % i] * (p - p / i) % p); for (int i = n - 1; i &gt;= 0; i--) b[i + 1] = int((ll)a[i] * inv[i + 1] % p); b[0] = 0; &#125; inline void Ln(const int *a, int *b, const int n) &#123; static int da[N], inva[N]; Inv(a, inva, n); Diff(a, da, n); Mul(inva, da, b, n); Inte(b, b, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; int n = read(); static int a[N], b[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); Poly::Ln(a, b, n); for (int i = 0; i &lt; n; i++) printf("%d ", b[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式加减乘除]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%2F</url>
    <content type="text"><![CDATA[所有的运算在 $\operatorname{mod} p$ 意义下进行 加法 Addition &amp; 减法 Subtraction只是充数的……对应项相加减就行 乘法 Multiplication转向 多项式乘法 NTT 除法 Division问题给定一个 $n$ 次多项式 $A(x)$ 和一个 $m$ 次多项式 $B(x)$ ，请求出多项式 $C(x)$, $R(x)$，满足以下条件： $C(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$ $A(x) = B(x) * C(x) + R(x)$ 方法如果没有 $R(x)$，直接求逆元就好了，那么我们现在就是想要搞掉这个多余的 $R(x)$。 考虑把 $F(x)$ 视作一个长为 $n$ 的多项式（高位补 $0$），把它翻转过来，为 x^n F(\frac{1}{x}) = \sum_{i = 0}^n a_i x^{n - i + 1}我们给 $A = B*C + R$ 同时代入 $\frac{1}{x}$ 依旧成立 A(\frac{1}{x}) = B(\frac{1}{x}) * C(\frac{1}{x}) + R(\frac{1}{x})等式两边同时乘上 $x^n$ x^n A(\frac{1}{x}) = x^{m}B(\frac{1}{x}) * x^{n - m} C(\frac{1}{x}) + x^nR(\frac{1}{x})相当于就是翻过来了（注意长度！） 我们发现，将 $R(x)$ （次数小于 $m$）视作长为 $n$ 的翻过来后，他的后 $n - m$ 项都是 $0$，那么我们现在给它模 $x^{n - m}$ 就会变成 $0$，同时 $x^{n - m} C(\frac{1}{x})$ 不会受到影响。 就变成了 x^n A(\frac{1}{x}) = x^{m}B(\frac{1}{x}) * x^{n - m} C(\frac{1}{x}) \mod x^{n - m}就可以直接求逆元算出来 $x^{n - m} C(\frac{1}{x})$，翻过来就得到 $C(x)$ 了。 因为只要的只是 $n - m$ 项来求 $C(x)$，所以 $A(x)$， $B(x)$ 有些项丢失了也没关系，只要求出来的 $C(x)$ 是准的，最后的 $R(x)$ 就是准的 最后再算 $R(x)$ R(x) = A(x) - B(x) * C(x)代码注意 $NTT$ 多余的部分一定要清空！！！ 模板 Luogu4512 多项式除法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 18 | 5; const int p = 998244353; const int g = 3; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = int((ll)x * x % p)) if (tim &amp; 1) ans = int((ll)ans * x % p); return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(g, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; inline void Plus(const int *a, const int *b, int *c, const int n) &#123; for (int i = 0; i &lt; n; i++) c[i] = (a[i] + b[i]) % p; &#125; inline void Minus(const int *a, const int *b, int *c, const int n) &#123; for (int i = 0; i &lt; n; i++) c[i] = (a[i] - b[i] + p) % p; &#125; inline void Mul(const int *A, const int *B, int *c, const int n) &#123; static int len, a[N], b[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + n, 0, sizeof(int[len - n])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) c[i] = int((ll)a[i] * b[i] % p); NTT(c, len, 1); memset(c + n, 0, sizeof(int[len - n])); &#125; void _Inv(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; _Inv(A, b, t); static int len, a[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] % p - (ll)a[i] * b[i] % p * b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; inline void Inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); _Inv(a, b, n); &#125; inline void Divide(const int *A, const int *B, int *c, int *r, const int n, const int m) &#123; static int a[N], b[N], inv[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); reverse(a, a + n), reverse(b, b + m); int t = n - m + 1; if (t &gt;= m) memset(b + m, 0, sizeof(int[t - m])); Inv(b, inv, t); Mul(a, inv, c, t); reverse(c, c + t); reverse(a, a + n), reverse(b, b + m); Mul(b, c, b, n), Minus(a, b, r, n); &#125; &#125; void work() &#123; int n = read(), m = read(); ++n, ++m; static int a[N], b[N], c[N], r[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); for (int i = 0; i &lt; m; i++) b[i] = read(); Poly::Divide(a, b, c, r, n, m); for (int i = 0; i &lt;= n - m; i++) printf("%d ", c[i]); puts(""); for (int i = 0; i &lt; m - 1; i++) printf("%d ", r[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式求逆]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[问题对于一个 $n$ 次多项式 $A(x)$，如果有一个多项式 $B(x)$ 满足 $A(x) * B(x) \equiv 1 \mod x^{n + 1}$，则称 $B(x)$ 是 $A(x)$ 在 $\mod x^{n + 1}$ 意义下的逆元。（通常也会规定多项式的系数在 $\mod p$ 的意义下。 方法通常采用 倍增 的做法。 考虑最基本的情况，$A(x)$ 在模 $x$ 的意义下只有一个常数项，那么它的逆元 $B(x)$ 也应当只有一个常数项，就是 $A(x)$ 的常数项在模 $p$ 下的逆元。 (后面懒得打 $(x)$ 了) 再考虑一半的情况：如果我们知道 $B_0$ 是 $A$ 在模 $x^{\lceil\frac{n}{2}\rceil}$ 意义下的逆元，我们现在要求的 $B$ 是 $A$ 在模 $x^n$ 意义下的逆元，即 A * B \equiv 1 \mod x^n相当于说，$A * B$ 的第 $1$ 到 $n - 1$ 项的系数都为 $0$，那么模一个低于 $n$ 次的 $x$ 的幂也同样是零，故 A * B \equiv A * B_0 \equiv 1 \mod x^{\lceil\frac{n}{2}\rceil}B - B_0 = 0 \mod x^{\lceil\frac{n}{2}\rceil}两边和模数同时平方 B^2 - 2B * B_0 + {B_0}^2 \equiv 0 \mod x^n再同时乘上 $A$ A * B^2 - 2A * B * B_0 + A * {B_0}^2 \equiv 0 \mod x^nB - 2B_0 + A * {B_0}^2 \equiv 0 \mod x^nB \equiv 2B_0 - A * {B_0}^2 \mod x^n然后就可以递增算了 $NTT$ 数组一定要保证多余的元素都是 $0$ 代码模板Luogu4238 多项式求逆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 20 | 5; const int p = 998244353; const int g = 3; namespace Poly &#123; int rev[N], w[N]; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = (ll)x * x % p) if (tim &amp; 1) ans = (ll)ans * x % p; return ans; &#125; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = 1, w[1] = qpow(g, (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void inv_separation(const int *A, int *b, const int n) &#123; if (n == 1) b[0] = qpow(A[0], p - 2); else &#123; int t = (n + 1) &gt;&gt; 1; inv_separation(A, b, t); static int len, a[N]; for (len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1); memcpy(a, A, sizeof(int[n])); memset(a + n, 0, sizeof(int[len - n])); memset(b + t, 0, sizeof(int[len - t])); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) b[i] = int((2LL * b[i] % p - (ll)a[i] * b[i] % p * b[i] % p + p) % p); NTT(b, len, 1); memset(b + n, 0, sizeof(int[len - n])); &#125; &#125; void inv(const int *A, int *b, const int n) &#123; static int a[N]; memcpy(a, A, sizeof(int[n])); inv_separation(a, b, n); &#125; &#125; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; int n = read(); static int a[N], b[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); Poly::inv(a, b, n); for (int i = 0; i &lt; n; i++) printf("%d ", b[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式全家桶 [目录]]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6-Menu%2F</url>
    <content type="text"><![CDATA[快速傅里叶变换 FFT 快速数论变换 NTT 任意模数 NTT（三模数版） 求逆 加减乘除 对数函数 ln 指数函数 exp 开根+快速幂 FWT]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意模数 NTT [多项式]]]></title>
    <url>%2F2019%2F03%2F11%2F%E4%B8%89%E6%A8%A1%E6%95%B0NTT%2F</url>
    <content type="text"><![CDATA[$NTT$ 的模数要求太严格了，根本压不住毒瘤出题人，所以就需要任意模数 $NTT$ 救场了。 题目求两个多项式 $F(x)$ 和 $G(x)$ ，求 $F(x) * G(x) \mod p$ 其中 $p$ 不一定能分解成 $p = 2^ka + 1$ 的形式 $1 \leqslant n, m \leqslant 10^5$，$0 \leqslant a_i \leqslant 10^9$，$2 \leqslant p \leqslant 10^9 + 9$ 方法我们发现，如果没有模数，卷积后每个位置的答案最大是 $10^9 \times 10^9 \times 10^5 = 10^{24}$，那么我们可以选 $3$ 个乘积大于 $10^{24}$ 的 $NTT$ 模数，分别做一次，得到对应模数下的乘积，然后用中国剩余定理合并得到模这三个模数乘积的答案。 常用模数：$469762049, 998244353, 1004535809$，原根均为 $3$，并且 $p + p &lt; 2^{63} + 1$ 因为答案显然小于三个质数乘积，那么模上三个质数乘积的答案就是这个数应该的值。 但是，$10^{24}$ 成功炸掉了 $long \ long$， 凉凉。 首先我们得到了每一位的答案： \begin{cases} ans \equiv a_0 \mod p_0 \\ ans \equiv a_1 \mod p_1 \\ ans \equiv a_2 \mod p_2 \\ \end{cases}考虑合并 $p_0$， $p_1$ 的答案（$p_0p_1 \leqslant 2^{63} - 1$），用中国剩余定理，记 $t_0$ 为合并 $p_0$、$p_1$ 的结果，则 t_0 = (a_0 p_1 \operatorname{inv}(p_1, p_0) + a_1 p_0 \operatorname{inv}(p_0, p_1)) \mod p_0p_1$\mod p_0 p_1$ 就要用龟速乘了，否则炸 $long \ long$，推一波 $O(1)$ 的龟速乘（$O(log n)$ 可能会被卡） 1234567inline ll mul(ll a, ll b,const ll p)&#123; static const long double eps = 1e-8; a = (a % p + p) % p; b = (b % p + p) % p; return ((a * b - ll((long double)a / p * b + eps) * p) % p + p) % p;&#125; 记 $t_1$ 使得 $ans = t_1 \times p_0p_1 + t_0$，现在就要求 $t_1$，再根据 $p_2$ 的结果 t_1 \times p_0p_1 + t_0 \equiv a_2 \mod p_2t_1 \times p_0p_1 \equiv a_2 - t_0 \mod p_2t_1 \equiv (a_2 - t_0)p_0^{-1}p_1^{-1} \mod p_2完结撒花~ 代码模板 Luogu4245 任意模数NTT 感觉自己写的思路清晰极了，不要注重常数啦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC &#123; typedef long long ll; const int N = 1 &lt;&lt; 20 | 5; const int MOD[] = &#123;469762049, 998244353, 1004535809&#125;; const int g = 3; int P, rev[N]; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; inline int qpow(int x, int tim, const int p) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = (ll)x * x % p) if (tim &amp; 1) ans = (ll)ans * x % p; return ans; &#125; struct Polynomial &#123; int p, w[N], r[N]; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = (ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p; a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2, p); i &lt; n; i++) a[i] = (ll)a[i] * t % p; &#125; &#125; void solve(const int *A, const int *B, const int n) &#123; w[0] = 1, w[1] = qpow(g, (p - 1) / n, p); for (int i = 2; i &lt; n; i++) w[i] = (ll)w[i - 1] * w[1] % p; static int a[N], b[N]; memcpy(a, A, sizeof(int[n])); memcpy(b, B, sizeof(int[n])); NTT(a, n, 0), NTT(b, n, 0); for (int i = 0; i &lt; n; i++) r[i] = (ll)a[i] * b[i] % p; NTT(r, n, 1); &#125; &#125;Poly[3]; inline ll mul(ll a, ll b,const ll p) &#123; static const long double eps = 1e-8; a = (a % p + p) % p; b = (b % p + p) % p; return ((a * b - ll((long double)a / p * b + eps) * p) % p + p) % p; &#125; void CRT(const int n) &#123; int p0 = MOD[0], p1 = MOD[1], p2 = MOD[2]; int *a = Poly[0].r, *b = Poly[1].r, *c = Poly[2].r; int inv2 = (ll)qpow(p0, p2 - 2, p2) * qpow(p1, p2 - 2, p2) % p2; ll Mod = (ll)p0 * p1; ll r0 = mul(p1, qpow(p1, p0 - 2, p0), Mod); ll r1 = mul(p0, qpow(p0, p1 - 2, p1), Mod); for (int i = 0; i &lt; n; i++) &#123; ll t0 = (mul(a[i], r0, Mod) + mul(b[i], r1, Mod)) % Mod; ll t1 = mul((c[i] - t0 % p2 + p2) % p2, inv2, p2); printf("%d ", int((mul(t1, Mod, P) + t0 % P) % P)); &#125; &#125; void work() &#123; int n = read(), m = read(); P = read(), ++n, ++m; static int len, a[N], b[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); for (int i = 0; i &lt; m; i++) b[i] = read(); for (len = 1; len &lt; n + m; len &lt;&lt;= 1); for (int i = 0; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((len &gt;&gt; 1) * (i &amp; 1)); Poly[0].p = MOD[0], Poly[0].solve(a, b, len); Poly[1].p = MOD[1], Poly[1].solve(a, b, len); Poly[2].p = MOD[2], Poly[2].solve(a, b, len); CRT(n + m - 1); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 参考资料安利博客 https://blog.csdn.net/zhouyuheng2003/article/details/85561887 像我这种没有追求的咸鱼对什么更加神(鬼)仙(畜)的奇技淫巧以优化常数没有什么兴趣的……]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速数论变换 NTT [多项式]]]></title>
    <url>%2F2019%2F03%2F11%2FNTT%2F</url>
    <content type="text"><![CDATA[用于加速多项式乘法，优点是可以取模， $FFT$ 处理复数域内的运算，$NTT$ 处理模域下的多项式计算 要求 系数必须都是整数 模数限制：能使用 $NTT$ 的模数必须 存在原根 并且 $p−1$ 是 $2$ 的若干次幂的倍数，例如最常见的 $998244353 = 2^{23} \times 7 \times 17+1$ ($998244353$ 的原根为 $3$) 先对这个模数 $p$ 求它的原根 $g$（枚举） $FFT$ 中找了满足 $\omega^n = 1$ 的复数 $\omega$ 作为单位根，同样 $NTT$ 中也要找一个 $\omega^n = 1$ 的整数作为单位根，根据原根定义 $g_{p - 1} = 1$，则有 \omega = g^{\frac{p - 1}{n}}然后后面的就跟 $FFT$ 一模一样了，运算就是整数间运算（除法变成乘逆元），取模即可 模板 Luogu3803 $\mod 998244353$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1 &lt;&lt; 21 | 5; const int p = 998244353;// const int g = 3; 懒人专用 int cnt, prime[N], rev[N], w[N]; vector&lt;int&gt; G[N]; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; inline int qpow(int x, int tim) &#123; int ans = 1; for (; tim; tim &gt;&gt;= 1, x = (ll)x * x % p) if (tim &amp; 1) ans = (ll)ans * x % p; return ans; &#125; void get_prime(int t) &#123; for (int i = 2; i * i &lt;= t; i++) if (!(t % i)) &#123; prime[++cnt] = i; while (!(t % i)) t /= i; &#125; if (t != 1) prime[++cnt] = t; &#125; inline int get_g() &#123; get_prime(p - 1); for (int g = 2; ; g++) &#123; int flag = 1; for (int i = 1; i &lt;= cnt; i++) flag &amp;= (qpow(g, (p - 1) / prime[i]) != 1); if (flag) return g; &#125; &#125; inline void init(const int n) &#123; w[0] = 1, w[1] = qpow(get_g(), (p - 1) / n); for (int i = 2; i &lt; n; i++) w[i] = int((ll)w[i - 1] * w[1] % p); for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); &#125; void NTT(int *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) for (int i = 0; i &lt; n; i += len &lt;&lt; 1) for (int k = 0; k &lt; len; k++) &#123; int x = a[i + k], y = int((ll)w[n / (len &lt;&lt; 1) * k] * a[i + len + k] % p); a[i + k] = (x + y) % p; a[i + len + k] = (x - y + p) % p; &#125; if (type) &#123; reverse(w + 1, w + n); for (int i = 0, t = qpow(n, p - 2); i &lt; n; i++) a[i] = int((ll)a[i] * t % p); &#125; &#125; void work() &#123; int n = read(), m = read(), len = 1; ++n, ++m; for (len = 1; len &lt;= n + m; len &lt;&lt;= 1); static int a[N], b[N]; for (int i = 0; i &lt; n; i++) a[i] = read(); for (int i = 0; i &lt; m; i++) b[i] = read(); init(len); NTT(a, len, 0), NTT(b, len, 0); for (int i = 0; i &lt; len; i++) a[i] = int((ll)a[i] * b[i] % p); NTT(a, len, 1); for (int i = 0; i &lt; n + m - 1; i++) printf("%d ", a[i]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 貌似 $NTT$ 比 $FFT$ 快不少]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速傅里叶变换 FFT [多项式]]]></title>
    <url>%2F2019%2F03%2F10%2FFFT%2F</url>
    <content type="text"><![CDATA[安利机房大佬zyt的博客讲解， 可以点链接，也可以直接看下面的pdf（去掉了代码） 珠玉在前，当然是要膜拜大佬伏地膜，所以这里只是简单记一下怎么推的和大佬的讲解（说白了就是学习笔记，基本是转载大佬的） 转载已获得博主同意。别走啊还有我自己补充完善的呢 我已经荣升全机房最后一个学会 $FFT$ 的孩子了……（话说我以前是怎么看着大家都会 $FFT$ 而无动于衷了整整几个月的……） 方法$FFT$ 的本质就是将两个多项式转换成点值表示法，点值可以直接相乘，然后再由点值得到它俩乘积的系数表示。那么，带进去的 $x$ 值和计算 $f(x)$ 的方法就是突破口。 单位根$n$ 次单位复数根 是满足 $\omega^n = 1$ 的复数 $\omega$，$n$ 次单位复数根恰好有 $n$ 个，这些根是 $\operatorname{e}^{\frac{2\pi k}{n}}$。 令 $a = \frac{2 \pi k}{n}$ \omega_n^k = \operatorname{e}^a = \cos(a) + i \sin(a) \ \ (0 \leqslant k < n)或者说： 将复数平面中的单位圆 $n$ 等分后幅角最小的等分点（不考虑 $1$） 称为 $n$ 次单位根，这些等分点可以表示为 $\omega_n^k(0 \leqslant k &lt; n)$ ， 它的幅角为 $\frac{2 \pi k}{n}$。 $\omega_n^k$ 是 $\omega_n^1$ 的 $k$ 次幂， $(\omega_n^1)^n = \omega_n^0 = 1$ 性质： （一）消去引理 \omega_{2n}^{2k} = \omega_n^k （二）折半引理 (\omega_n^k)^2 = \omega_{\frac{n}{2}}^k \omega_n^{k + \frac{2}{n}} = -\omega_n^k 折半引理对于用分治策略来对多项式的系数与点值表达进行相互转换是非常重要的，因为它保证了递归子问题的规模只是递归调用前的一半。 （三）zyt博客里面那个不知名的性质 \omega_n^{k + an} = \omega_n^k \ (a \in Z) （四）求和引理 对于任意整数 $n \geqslant 1$ 和不能被 $n$ 整除的非负整数 $k$， 有 \sum_{j = 0}^{n - 1} (\omega_n^k)^j = 0证明：等比数列求和公式对复数依旧适用 \sum_{j = 0}^{n - 1} (\omega_n^k)^j = \frac{(\omega_n^k)^n - 1}{\omega_n^k - 1} = \frac{(\omega_n^n)^k - 1}{\omega_n^k - 1} = \frac{(1)^k - 1}{\omega_n^k - 1} = 0离散傅里叶变换（DFT）$DFT$ 是把多项式从系数表示法转换成点值表示法。跟 $O(n^2)$ 的直接带值算相比，主要在于 代入单位根（幂） 和 奇偶分组运算 将 $n$ 次单位根的 $0$ 到 $n - 1$ 次幂带入 $n - 1$ 次多项式 $A(x)$ （$n + 1$ 组对应的 $x$ 和 $A(x)$ 存在唯一一个最高次数为 $n$ 的多项式 $A(x)$），对 $A(x)$ 奇偶分组： A_{0}(x) = \sum_{i = 0}^{\frac{n - 1}{2}} a_{2i} \cdot x^i A_{1}(x) = \sum_{i = 0}^{\frac{n - 1}{2}} a_{2i + 1} \cdot x^i则有 A(x) = A_{0}(x^2) + x \cdot A_{1}(x^2)带入单位根 A(\omega_n^k) = A_{0}(\omega_n^{2k}) + \omega_n^k \cdot A_{1}(\omega_n^{2k}) \\根据折半引理 A(\omega_n^k) = A_{0}(\omega_{\frac{n}{2}}^{k}) + \omega_n^k \cdot A_{1}(\omega_{\frac{n}{2}}^{k}) \\但是这样转化就有了一个特殊情况：当 $\frac{n}{2} \leqslant k &lt; n$ 的时候，根据折半引理（和某不知名性质）： \omega_{\frac{n}{2}}^{k} = \omega_{\frac{n}{2}}^{k - \frac{n}{2}}\omega_{n}^{k}= \omega_{n}^{k - \frac{n}{2}}令 $t = k - \frac{n}{2}$故 A(\omega_n^k) = A_0(\omega_{\frac{n}{2}}^t) - \omega_{n}^t \cdot A_1(\omega_{\frac{n}{2}}^t)这样就可以递归处理，每次用 $\omega_{len}^k$ 和 $\omega_{len}^{k + \frac{len}{2}}$ 合并计算了（$len$ 为当前递归的区间长度） 为了每层的区间长度都能是 $2$ 的倍数，所以把 $n - 1$ 扩成 $2$ 的幂次处理。 离散傅里叶反变换（IDFT）这一段参考了《算法导论》，zyt大佬写的也是非常不错的（大佬的脑补真厉害） 首先令 $\omega_n^k(0 \leqslant k &lt; n)$ 代入多项式 $A(x)$ 得到的点值为 $y(k)$，写成矩阵乘积 $y = V_n a$ ，其中 $V_n$ 是一个由 $\omega_n$ 适当幂次填充成的矩阵，对于 $j,k \in \{ t | 0 \leqslant t &lt; n \}$，$V_n$ 的 $(j, k)$ 处的元素为 $\omega_n^{jk}$ （Hexo貌似不支持矩阵所以以图片充数） 那么对于逆运算 $a = DFT^{-1}(y)$ 我们把 $y$ 乘上 $V_n$ 的逆矩阵 $V_n^{-1}$ 得到 定理：对于 $p,k \in \{ t | 0 \leqslant t &lt; n \}$，$V_n^{-1}$ 的 $(p, k)$ 处的元素为 $\frac{\omega_n^{-jk}}{n}$ 证明： 考虑 $V_n^{-1} V_n$（$n \times n$ 的单位矩阵） 中 $(p, q)$ 处的元素： (这个怎么也显示不出来啊) 根据求和公式，如果 $q - p = 0$，此和为 $1$，否则此和为 $0$。注意：只有 $-(n - 1) \leqslant q - p \leqslant n - 1$，使得 $q - p$ 不能被 $n$ 整除，才能应用求和定理。 得到了逆矩阵 $V_n^{-1}$，可以推导出 $DFT_n^{-1}(y)$ a_j = \frac{1}{n} \sum_{k = 0}^{n - 1} y_k \omega_n^{-jk} \ \ \ (0 \leqslant p < n)我们直接将 $y$ 代入到 $DFT$ 中，用 $\omega_n^{-1}$ 代替 $\omega_n^1$ ，并将所得结果除以 $n$，就得到系数啦！ 这样我们得到了一个递归的 $FFT$，常数巨大，代码呈上 zyt 的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const int N = (1e6 + 10) * 4;const double PI = 3.141592653589793238462643383279502884197169399375105820974944;struct cpx&#123; double a, b; cpx()&#123;&#125; cpx(const double x, const double y = 0) : a(x), b(y)&#123;&#125; cpx operator + (const cpx &amp;c) const &#123; return (cpx)&#123;a + c.a, b + c.b&#125;; &#125; cpx operator - (const cpx &amp;c) const &#123; return (cpx)&#123;a - c.a, b - c.b&#125;; &#125; cpx operator * (const cpx &amp;c) const &#123; return (cpx)&#123;a * c.a - b * c.b, a * c.b + b * c.a&#125;; &#125;&#125;;int n, m;cpx a[N], b[N], buf[N];inline cpx omega(const int n, const int k)&#123; return (cpx)&#123;cos(2 * PI * k / n), sin(2 * PI * k / n)&#125;;&#125;void FFT(cpx *a, const int n, const bool inv)&#123; if (n == 1) return; static cpx buf[N]; int mid = n &gt;&gt; 1; for (int i = 0; i &lt; mid; i++) &#123; buf[i] = a[i &lt;&lt; 1]; buf[i + mid] = a[i &lt;&lt; 1 | 1]; &#125; memcpy(a, buf, sizeof(cpx[n])); //now a[i] is coefficient FFT(a, mid, inv), FFT(a + mid, mid, inv); //now a[i] is point value //a[i] is A1(w_n^i), a[i + mid] is A2(w_n^i) for (int i = 0; i &lt; mid; i++) &#123;//calculate point value of A(w_n^i) and A(w_n^&#123;i+n/2&#125;) cpx x = omega(n, i * (inv ? -1 : 1)); buf[i] = a[i] + x * a[i + mid]; buf[i + mid] = a[i] - x * a[i + mid]; &#125; memcpy(a, buf, sizeof(cpx[n]));&#125;int work()&#123; read(n), read(m); for (int i = 0; i &lt;= n; i++) &#123; int tmp; read(tmp); a[i] = tmp; &#125; for (int i = 0; i &lt;= m; i++) &#123; int tmp; read(tmp); b[i] = tmp; &#125; for (m += n, n = 1; n &lt;= m; n &lt;&lt;= 1); FFT(a, n, false), FFT(b, n, false); for (int i = 0; i &lt; n; i++) a[i] = a[i] * b[i]; FFT(a, n, true); for (int i = 0; i &lt;= m; i++) write((int)((a[i].a / n) + 0.5)), putchar(' '); return 0;&#125; 实现与优化求单位根的幂次因为数学库里面 $\cos$ 和 $\sin$ 函数速度“可人”，所以可以算出来单位根然后用它来算单位根的幂。 $IDFT$ 的时候用 $\omega_n^{-1}$ 代替 $\omega_n$两种优化： 在 $IDFT$ 的时候传一个标记，如果有标记就 $reverse(\omega + 1, \omega + n)$ ($reverse$ 不就相当于是变成了 $\omega_n^{-k}$） 预处理 $\omega_n^{-k}$ ，$FFT$ 时传此时用的是 $\omega_n^{k}$ 还是 $\omega_n^{-k}$ 。$\omega_n^{-k}$ 相当于 $\omega_n^{k}$ 关于 实轴对称，横坐标不变，纵坐标相反。 递归太慢了，我要迭代！考虑我们奇偶分组的过程 $\{a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7\}$ 递归到最后一层时变成了 $\{a_0, a_4, a_2, a_6, a_1, a_5, a_3, a_7\}$，大佬告诉我说 一个数最终变成的数的下标是它的下标的二进制表示颠倒过来，例如 $1_{10} = 001_{2}$，$4_{10} = 100_{2}$，那么我们可以预处理一个 $rev$ 数组，其中 $rev[i]$ 表示 $a_i$ 递归到最后一层会到哪个位置。例如，当 $n = 8$ 时，$rev[1] = 4$。 根据 $rev$ 的定义，我们可以递推得到它 1rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)) 其中 $n$ 为大于原题中给定 $n$ 的最下的 $2$ 的幂次。 如图，矩形部分就应当是 $i &gt;&gt; 1$， $rev[i]$ 中的矩形是 $rev[i &gt;&gt; 1] &gt;&gt; 1$ （因为位数是固定的，为 $log_2n$，$i&gt;&gt;1$ 最初的多的一个 $0$ 导致 $rev[i &gt;&gt; 1]$ 最后会有一位多余的 $0$，所以还要右移一位），$n &gt;&gt; 1$ 就是 $1 &lt;&lt; (log_2n - 1)$。 这样就可以直接先变成最后一层分组的的状态，然后一层一层从下向上的合并啦。 注意！当递归的区间长度为 $len$ 时，查询 $\omega_{len}^k$ 相当于查 $\omega_n^{\frac{nk}{len}}$，一定要先除再乘，防止 $nk$ 爆 $int$ 毕竟这是zyt神仙流过的血啊 \omega_{len}^k = \omega_{nlen}^{nk} = \omega_{n}^{\frac{nk}{len}}代码模板 Luogu3803 多项式乘法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N = 1 &lt;&lt; 21 | 5; const double PI = acos(-1); int rev[N]; struct cmplex &#123; double re, im; cmplex(double _re = 0.0, double _im = 0.0) : re(_re), im(_im) &#123; &#125; cmplex operator + (const cmplex &amp;a) const &#123; return cmplex(re + a.re, im + a.im); &#125; cmplex operator - (const cmplex &amp;a) const &#123; return cmplex(re - a.re, im - a.im); &#125; cmplex operator * (const cmplex &amp;a) const &#123; return cmplex(re * a.re - im * a.im, re * a.im + im * a.re); &#125; &#125;w[N]; inline void init(const int n) &#123; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((n &gt;&gt; 1) * (i &amp; 1)); w[0] = cmplex(1, 0), w[1] = cmplex(cos(2 * PI / n), sin(2 * PI / n)); for (int i = 2; i &lt; n; i++) w[i] = w[i - 1] * w[1]; &#125; void FFT(cmplex *a, const int n, const int type) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); if (type) reverse(w + 1, w + n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) // 枚举递归区间长度 len &lt;&lt; 1 for (int i = 0; i &lt; n; i += (len &lt;&lt; 1)) // 枚举第几个区间 for (int k = 0; k &lt; len; k++) // 将这个区间内的元素合并 &#123; cmplex x = a[i + k], y = w[n / (len &lt;&lt; 1) * k] * a[i + len + k]; a[i + k] = x + y; a[i + len + k] = x - y; &#125; if (type) reverse(w + 1, w + n); &#125; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void work() &#123; int n = read(), m = read(), len; ++n, ++m; for (len = 1; len &lt; n + m; len &lt;&lt;= 1); init(len); static cmplex a[N], b[N]; for (int i = 0; i &lt; n; i++) a[i] = cmplex(read()); for (int i = 0; i &lt; m; i++) b[i] = cmplex(read()); FFT(a, len, 0), FFT(b, len, 0); for (int i = 0; i &lt; len; i++) a[i] = a[i] * b[i]; FFT(a, len, 1); for (int i = 0; i &lt; n + m - 1; i++) printf("%d ", int(a[i].re / len + 0.5)); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 我怎么转载别人的还敲了这么长啊……果然是太菜了啥都不会所以才要多记点为将来忘了做准备]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小圆覆盖 [随机增量法][计算几何]]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[emmmmmm，简单记一下怎么做，不证明 问题给你 $n$ ($n \leqslant 10^5$) 个点的坐标，要求找一个最小的包含所有点的圆。 方法随机增量法 一、random_shuffle 打乱所有的点 二、一个个加入点，记 $C_i$ 为前 $i$ 个点的最小覆盖圆 $i = 1 \rightarrow$ 单点，直接作为圆心 $i = 2 \rightarrow$ 和 $1$ 连线，以中点作为圆心，连线长度作为直径 $i = 3 \rightarrow$ 点 $1,2,3$ 三点确定一个圆 $i = 4 \to n$ 已经被圆覆盖了就不理了，否则 $C_i$ 一定比 $C_{i - 1}$ 大，点 $i$ 一定在圆上，再枚举 $j \in [1, i)$， $k \in [1,j)$ 三点再确定圆就可以了 震惊，看似 $O(n^3)$ 的算法实际期望只有 $O(n)$ ！不证明QWQ 附加芝士： 三点确定一个圆 前提：三点不共线 圆心为 $\triangle{ABC}$ 的外心，即两条边中垂线的交点 前置计算几何基本芝士 已知直线 $AB$ $(P = A + t v, v = B - A)$，其中垂线为 $Q = Middle(A, B) + t w$ 其中 $w = (-v.y, v.x)$ 或 $(v.y, -v.x)$ 12345678910111213141516171819// 线段中点inline Point Middle(const Point &amp;A, const Point &amp;B) &#123; return Point((A.x + B.x) / 2, (A.y + B.y) / 2); &#125;// 中垂线inline void Vertical(const Point &amp;A, const Point &amp;B, Point &amp;p, Vector &amp;v)&#123; p = Middle(A, B); Vector tmp = B - A; v.x = -tmp.y, v.y = tmp.x;&#125;inline void Circle(const Point &amp;A, const Point &amp;B, const Point &amp;C)&#123; Point P, Q; Vector v, w; Vertical(A, B, P, v), Vertical(A, C, Q, w); Vector u = P - Q; ld t = Cross(w, u) / Cross(v, w); // 求交点 O = P + v * t, R = Dist(O, A); &#125; 貌似还可以用圆的方程直接算（但是我是懒人） 例题Luogu 1742bzoj 1336 &amp; bzoj 1337 多倍经验 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long double ld; const int N = 100010; const ld eps = 1e-12; int n; ld R; struct Point &#123; ld x, y; Point(const ld _x = 0, ld _y = 0) : x(_x), y(_y) &#123; &#125; &#125;a[N], O; typedef Point Vector; inline Vector operator + (const Vector &amp;A, const Vector &amp;B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125; inline Vector operator - (const Point &amp;A, const Point &amp;B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125; inline Vector operator * (const Vector &amp;A, const ld p) &#123; return Vector(A.x * p, A.y * p); &#125; inline ld Dot(const Vector &amp;A, const Vector &amp;B) &#123; return A.x * B.x + A.y * B.y; &#125; inline ld Length(const Vector &amp;A) &#123; return sqrt(Dot(A, A)); &#125; inline ld Dist(const Point &amp;A, const Point &amp;B) &#123; return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)); &#125; inline ld Cross(const Vector &amp;A, const Vector &amp;B) &#123; return A.x * B.y - A.y * B.x; &#125; inline Point Middle(const Point &amp;A, const Point &amp;B) &#123; return Point((A.x + B.x) / 2, (A.y + B.y) / 2); &#125; inline void Vertical(const Point &amp;A, const Point &amp;B, Point &amp;p, Vector &amp;v) &#123; p = Middle(A, B); Vector tmp = B - A; v.x = -tmp.y, v.y = tmp.x; &#125; inline void Circle(const Point &amp;A, const Point &amp;B, const Point &amp;C) &#123; Point P, Q; Vector v, w; Vertical(A, B, P, v), Vertical(A, C, Q, w); Vector u = P - Q; ld t = Cross(w, u) / Cross(v, w); O = P + v * t, R = Dist(O, A); &#125; void work() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%Lf%Lf", &amp;a[i].x, &amp;a[i].y); random_shuffle(a + 1, a + n); O = a[1], R = 0; for (int i = 2; i &lt;= n; i++) if (Dist(a[i], O) &gt; R) &#123; O = a[i], R = 0; for (int j = 1; j &lt; i; j++) if (Dist(a[j], O) &gt; R) &#123; O = Middle(a[i], a[j]), R = Dist(a[i], O); for (int k = 1; k &lt; j; k++) if (Dist(a[k], O) &gt; R) Circle(a[i], a[j], a[k]); &#125; &#125; printf("%.10f\n%.10f %.10f", (double)R, (double)O.x, (double)O.y); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一些很好用的网站]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%B0%E4%B8%80%E4%BA%9B%E5%BE%88%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[图床 sm.ms $\LaTeX$ 各种命令，符号 garfielder007 和 战舰~ Paste code ubuntu pastebin 画图神器（坐标图）GeoGebra 持续更新……]]></content>
      <categories>
        <category>杂类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj1132 [POI2008]Tro [计算几何]]]></title>
    <url>%2F2019%2F03%2F02%2Fbzoj1132%2F</url>
    <content type="text"><![CDATA[题目Bzoj1132Luogu3476 平面上有 $n$ 个点. 求出所有以这 $n$ 个点为顶点的三角形的面积和 ($n \leqslant 3000$， 坐标值在 $[0,10000]$ 范围内) 分析首先我们如果 $O(n^3)$ 枚举三角形三个顶点 $(A, B, C)$，肯定是 $A:1 \to n - 2$， $B:A + 1 \to n - 1$， $C:B + 1 \to n$。 那么我们考虑枚举点 $A$，因为 $S_{\triangle{ABC}} = \frac{\operatorname{abs}(\operatorname{Cross}(B - A, C - A))}{2}$, 再枚举点 $B$，那么$\overrightarrow{BA}$ 是确定的，因为 $\operatorname{Cross}(P, Q) = P.x \times Q.y - P.y \times Q.x$，那么我们可以预处理 $\sum\overrightarrow{CA}.x$ 和 $\sum\overrightarrow{CA}.y$ 就可以做到 $O(n^2)$ 求解了。 但是，因为叉积是有向面积，所以可能是负值，如图 如图，当 $\color{blue}{\overrightarrow{BA}}$ 确定时，若 $\color{orange}{\overrightarrow{CA}}$ 处在红色区域内，$\operatorname{Cross}(B - A, C - A))$ 为负值。 懒人为了不重新想咋做当然要想办法去掉这个负值的情况。 操作一：对初始点按照 $x$ 轴排序，就可以去掉二三象限的情况了。操作二：以 $A$ 为原点，对于 $A$ 以后的点按照极角排序，就可以保证枚举到 $B$ 时剩下的 $sumx$ 和 $sumy$ 都是不在红色区域范围内的了。 答案其实只有 $.0$ 或者 $.5$ 两种，极角排序可以直接用 $\operatorname{atan2}(y,x)$ 表示点 $(x, y)$ 的极角大小（弧度值），因为库里面的 $\operatorname{atan2}$ 特别慢数学函数貌似都很慢，预处理后再排序，相比排序是计算跑的飞快 代码真是又短又好写，$ans$ 别忘了开 $long long$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; typedef pair&lt;int, int&gt; pii; const int N = 3010; pii pos[N]; struct node &#123; pii ve; double angle; bool operator &lt; (const node &amp;t) const &#123; return angle &lt; t.angle; &#125; &#125; arr[N]; void work() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;pos[i].first, &amp;pos[i].second); sort(pos + 1, pos + 1 + n); ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int num = 0; for (int j = i + 1; j &lt;= n; j++) &#123; arr[++num].ve = pii(pos[j].first - pos[i].first, pos[j].second - pos[i].second); arr[num].angle = atan2(arr[num].ve.second, arr[num].ve.first); &#125; sort(arr + 1, arr + 1 + num); int sumx = 0, sumy = 0; for (int j = 1; j &lt;= num; j++) sumx += arr[j].ve.first, sumy += arr[j].ve.second; for (int j = 1; j &lt;= num; j++) &#123; sumx -= arr[j].ve.first, sumy -= arr[j].ve.second; ans += (ll)arr[j].ve.first * sumy - (ll)arr[j].ve.second * sumx; &#125; &#125; printf("%lld.%d\n", ans &gt;&gt; 1, (ans &amp; 1) ? 5 : 0); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>叉积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狄利克雷卷积 [数学]]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[没啥写的，随便写点 记几个常用函数 \begin{aligned} \epsilon(n) &= \begin{cases} 1 \ \ (n = 1) \\ 0 \ \ otherwise \\ \end{cases} \\ 1(n) &= 1 \\ id_k(n) &= n^k \\ \mu(n) &= \begin{cases} 1 \ \ (n = 1) \\ (-1)^k \ \ (n 为 k 个不同的质数的乘积) \\ 0 \ \ (n 含有质数平方因子) \end{cases} \end{aligned}狄利克雷卷积 (f * g)(n) = \sum_{d | n} f \left( d \right) g \left( \frac{n}{d} \right)性质 $f ∗ g = g ∗ f$ $(f ∗ g) ∗ h = f ∗ (g ∗ h)$ $f ∗ (g + h) = f ∗ g + f ∗ h$ $f ∗ \epsilon = \epsilon ∗ f = f$ 若 $f (1) \neq 0$,则存在唯一函数 $f^{−1}$ 使得 $f ∗ f^{−1} = ε$ 若 $f$, $g$ 为积性函数,则 $f ∗ g$ 也为积性函数 若 $h$ 为完全积性函数, $(f ∗ g) · h = (f · h) ∗ (g · h)$ 常用狄利克雷卷积$\mu$ 是 $1$ 的逆，所以 \mu * 1 = \epsilon即 \sum_{d|n} \mu(d) = \epsilon(n) = [n = 1]由 $\varphi$ 的性质 \varphi * 1 = id \\即 \sum_{d|n} \varphi(d) = n也可得到 \mu * id = \varphi \\ \sum_{d=1}^n \varphi(d) \lfloor \frac{n}{d} \rfloor = \sum_{i=1}^n i = \frac{(n + 1) \times n}{2}]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>狄利克雷卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杜教筛 [筛法]]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[杜教筛解决的是一些满足特殊性质的数论函数的前缀和问题。 问题给定一个 $n$ 和函数 $f(x)$，求 S(n) = \sum_{i = 1} ^ n f(i)方法主要思想是构造一个函数 $g(x)$ 考虑 $(f * g)(n)$ 的前缀和可以变换为： \begin{aligned} & \ \ \ \ \ \sum_{i = 1}^n (f * g)(i) \\ &= \sum_{i = 1}^n \sum_{d | i} g(i) f(\frac{i}{d}) \\ &= \sum_{d = 1}^n \sum_{i = 1}^{\lfloor \frac{n}{d} \rfloor} g(d)f(i) \\\ &= \sum_{d = 1}^n g(d) S(\lfloor \frac{n}{d} \rfloor) \\ &= g(1)S(n) + \sum_{d = 2}^n g(d)S(\lfloor \frac{n}{d} \rfloor)\\ \end{aligned}即 g(1)S(n) = \sum_{i = 1}^n (f * g)(i) - \sum_{d = 2}^n g(d)S(\lfloor \frac{n}{d} \rfloor)S(n) = \frac{\sum_{i = 1}^n (f * g)(i) - \sum_{d = 2}^n g(d)S(\lfloor \frac{n}{d} \rfloor)}{g(1)}只要找到一个 $g$ 使得 $f ∗ g$ 和 $g$ 的前缀和都可以快速计算，就可以使用上式计算 $S(n)$ 分析由于作者太菜了，所以不会证明时间复杂度到底怎么算的…… 如果使用上式，对所有的 $S(\lfloor \frac{n}{d} \rfloor)$ 记忆化，时间复杂度是 $O(n^{\frac{3}{4}})$ 的 实际上,我们可以用线性筛预处理一部分,用之前的式子解决其它部分来优化时间复杂度,设预处理了前 $B$ 个，当时间复杂度最优时 $B = \sqrt{\frac{n}{B}}$， 解得 $B = n^{\frac{2}{3}}$ ，时间复杂度是 $O(n ^ {\frac{2}{3}})$ 实现时，可以将 $S(x)$ 的值存入数组的第 $\lfloor\frac{n}{x}\rfloor$ 位以避免使用 $map$ 等数据结构，可以证明这样不会冲突。 构造最麻烦的还是构造 $g$ 函数了…… 记几个常用的 安利 狄利克雷卷积，不知道的先看一下 $\mu 1 = \epsilon$ ， $\varphi 1 = id_1$ ， $id_1 * \mu = \varphi$ \sum_{i = 1}^n id_2(i) = \frac{n(n + 1)(2n + 1)}{6}\sum_{i = 1}^n id_3(i) = (1 + 2 + 3 + \cdots + n)^2 = \left( \sum_{i = 1}^n id_1(n) \right) ^2如果看到了还会再补充的 例题模板Luogu4213 [模板] 杜教筛 求 $\varphi$ 和 $\mu$ 的前缀和 根据 $\mu 1 = \epsilon$ $\varphi 1 = id$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; typedef unsigned int uint; typedef pair&lt;ll, int&gt; pli; const int B = 1664510, S = 1291; int n, T; ll SumPhi[B + 5], ResPhi[S + 5]; int SumMu[B + 5], ResMu[S + 5]; void init() &#123; static int cnt, vis[B + 5], prime[B + 5], phi[B + 5], mu[B + 5]; phi[1] = mu[1] = 1; for (int i = 2; i &lt;= B; i++) &#123; if (!vis[i]) &#123; prime[cnt++] = i; phi[i] = i - 1; mu[i] = -1; &#125; for (int j = 0, t; j &lt; cnt &amp;&amp; (t = i * prime[j]) &lt;= B; j++) &#123; vis[t] = 1; if (i % prime[j] == 0) &#123; phi[t] = phi[i] * prime[j]; mu[t] = 0; break; &#125; phi[t] = phi[i] * (prime[j] - 1); mu[t] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= B; i++) &#123; SumPhi[i] = SumPhi[i - 1] + phi[i]; SumMu[i] = SumMu[i - 1] + mu[i]; &#125; &#125; bool vis[S + 5]; pli GetSum(const int x) &#123; if (x &lt;= B) return pli(SumPhi[x], SumMu[x]); int t = n / x; if (!vis[t]) &#123; vis[t] = 1; ResPhi[t] = ((ll)x + 1) * x / 2; ResMu[t] = 1; for (uint l = 2, r; l &lt;= x; l = r + 1) &#123; pli res = GetSum(x / l); r = x / (x / l); ResPhi[t] -= (r - l + 1) * res.first; ResMu[t] -= (r - l + 1) * res.second; &#125; &#125; return pli(ResPhi[t], ResMu[t]); &#125; void work() &#123; init(); scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); memset(vis + 1, 0, sizeof(bool) * n / B); pli ans = GetSum(n); printf("%lld %d\n", ans.first, ans.second); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 后面的就不放代码了 Luogu3768 简单的数学题Luogu3768 简单的数学题 求 \sum_{i = 1}^n \sum_{j = 1}^n i j \operatorname{gcd}(i j) \mod p$1 \leqslant n \leqslant 10^{10}$ 莫比乌斯反演一发 = \sum_{i = 1}^n \sum_{j = 1}^n i j \sum_{d | i, d | j} d \sum_{g | \frac{i}{d}, g | \frac{j}{d}} \mu(g)记 $T = dg$ \begin{aligned} &= \sum_{T = 1}^n \sum_{d | T} d \mu(\frac{T}{d}) \sum_{i = 1}^{\lfloor \frac{n}{T} \rfloor} \sum_{j = 1}^{\lfloor \frac{n}{T} \rfloor} i j T^2 \\ &= \sum_{T = 1}^n SumId_1(\lfloor \frac{n}{T} \rfloor)^2 T^2 \sum_{d | T} d \mu(\frac{T}{d}) \\ &= \sum_{T = 1}^n SumId_1(\lfloor \frac{n}{T} \rfloor)^2 f(T) \\ \end{aligned}因为 $\mu id_1 = \varphi$ ，所以 $f(T) = T^2 \varphi(T)$ 数论分块，重点变成求 $f(T)$ 的前缀和 再因为 $\varphi * 1 = id$，就令 $g = (1 \cdot id_2) = id_2$ \begin{aligned} & \ \ \ \ \ (\varphi \cdot id_2) * (1 \cdot id_2) \\ &= (\varphi * 1) \cdot id_2 \\ &= id \cdot id_2 \\ &= id_3 \end{aligned}故 $g = id_2$，$f * g = id_3$ bzoj4652[NOI2016] 循环之美前几天写的了 bzoj4652[NOI2016] 循环之美 [杜教筛] 也许哪天就补上了 $Min25$ 筛 啥时候学会了再说]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3739 DZY loves math VIII [莫比乌斯反演]]]></title>
    <url>%2F2019%2F02%2F27%2Fbzoj3739%2F</url>
    <content type="text"><![CDATA[题目bzoj3739 \sum_{i = 1}^n sum_{j = 1}^n \mu \left(\operatorname{lcm}(i, j)^{\operatorname{gcd}(i, j)} \right)$T (T \leqslant 10^3)$ 组数据，$n \leqslant 10^7$ 分析首先，当 $\operatorname{gcd}(i, j) \neq 1$ 时，根据 $\mu$ 的定义答案为 $0$，那么上式就变成了 \sum_{i = 1}^n \sum_{j = 1}^n \mu (ij) [\operatorname{gcd}(i, j) = 1] \\ \begin{aligned} &= \sum_{i = 1}^n \mu (i) \sum_{j = 1}^n \mu(j) \sum_{d | i, d|j} \mu(d) \\ &= \sum_{d = 1}^n \mu(i) \sum_{d | i} \mu(d) \sum_{j = 1}^{\frac{i}{d}} \mu(j) \end{aligned}记 $S(i, d) = \sum_{j = 1}^{\frac{i}{d}} \mu(dj)$ ，发现 $S(i, d) = S(i - d, d) + \mu(i)$ = \sum_{i = 1}^n \mu(i) \sum_{d | i} \mu(d) S(i,d)因为只有当 $i$ 不含有质数的平方因子时 $\mu(i) \neq 0$，对这样的 $i$ 分解质因数，更新 $S(i,d)$ 即可（$S(i,d)$ 只用保存 $d$ 那一维就行了） 因为 $i$ 没有分解质数平方因子，预处理 $p[x]$ 为 $x$ 的最小质因子，然后沿着 $p$ 就可以分解 $i$ 了，前 $9$ 个质数的乘积就已经大于 $10^7$ 了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N = 1e7; int T, cnt, tot, query[1010], ans[N], mu[N + 10], prime[N / 10 + 10], f[N], a[1010], p[N]; bool vis[N + 10]; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; inline void init() &#123; mu[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!vis[i]) p[i] = prime[++cnt] = i, mu[i] = -1; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) &#123; int k = i * prime[j]; vis[k] = 1; p[k] = prime[j]; if (i % prime[j] == 0) &#123; mu[k] = 0; break; &#125; else mu[k] = -mu[i]; &#125; &#125; &#125; int getans(int now, int pai, int val) &#123; if (now &gt; tot) &#123; f[pai] += val; return f[pai] * mu[pai]; &#125; return getans(now + 1, pai * a[now], val) + getans(now + 1, pai, val); &#125; void work() &#123; init(); T = read(); int mx = 0; for (int i = 1; i &lt;= T; i++) query[i] = read(), mx = max(mx, query[i]); for (int i = 1; i &lt;= mx; i++) &#123; ans[i] += ans[i - 1]; if (!mu[i]) continue; tot = 0; int x = i; while (x &gt; 1) a[++tot] = p[x], x /= p[x]; ans[i] += mu[i] * getans(1, 1, mu[i]); &#125; for (int i = 1; i &lt;= T; i++) printf("%d\n", ans[query[i]]); &#125;&#125; int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1109 [POI2007]堆积木Klo [二维偏序]]]></title>
    <url>%2F2019%2F02%2F27%2Fbzoj1109%2F</url>
    <content type="text"><![CDATA[题目bzoj1109 $Mary$ 在她的生日礼物中有一些积木。那些积木都是相同大小的立方体。每个积木上面都有一个数。 $Mary$ 用他的所有积木垒了一个高塔。妈妈告诉 $Mary$ 游戏的目的是建一个塔，使得最多的积木在正确的位置。一个上面写有数i的积木的正确位置是这个塔从下往上数第i个位置。 $Mary$ 决定从现有的高塔中移走一些，使得有最多的积木在正确的位置。请你告诉 $Mary$ 她应该移走哪些积木。 第一行为一个数 $n$，表示高塔的初始高度。第二行包含 $n$ 个数 $a_1$, $a_2$, $\cdots$ , $a_n$，表示从下到上每个积木上面的数。($1\leqslant n\leqslant100000$, $1\leqslant ai\leqslant1000000$)。 分析我们记 $b_i = i - a_i$ 首先有一个二维的 $dp$ 方程，记 $f_{i, j}$ 为前 $i$ 个删了 $j$ 个最多使多少个积木在正确的位置上， 转移为 f_{i, j} = max(f_{i - 1, j} + [b_i = j], f_{i - 1, j - 1})但是这个东西很难优化或者说我不会， GG。 然后就有一种新的 $dp$ 方程，记 $f_i$ 表示第 $i$ 个在自己位置上的最大值， 转移为 f_i = max(f_j) + 1其中 $j$ 满足 $j &lt; i$，$a_j &lt; a_ i$, $b_j \leqslant b_i$ （别忘了$b_j \geqslant 0$， $b_i \geqslant 0$ ）, 又因为 b_j \leqslant b_i \Rightarrow j - a_j \leqslant i - a_i \Rightarrow a_i - a_ j \leqslant i - j发现由 $a_j &lt; a_i$， $b_j \leqslant b_i$ 可以得到 $j &lt; i$，所以就变成了一个二维偏序问题。对 $a$ 排序，再用树状数组维护前缀最大值和单点插入即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std; namespace TYC&#123; typedef pair&lt;int, int&gt; pii; const int N = 100010; int n, ans, dp[N], val[N]; pii arr[N]; #define lowbit(x) (x) &amp; -(x) inline void update(int x, const int w) &#123; for (; x &lt;= n; x += lowbit(x)) val[x] = max(val[x], w); &#125; inline int query(int x) &#123; if (x &lt;= 0) return 0; int mx = 0; for(; x; x -= lowbit(x)) mx = max(mx, val[x]); return mx; &#125; void work() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;arr[i].second); arr[i].first = i - arr[i].second; &#125; sort(arr + 1, arr + 1 + n); for (int i = 1; i &lt;= n; i++) &#123; if (arr[i].first &lt; 0) continue; ans = max(ans, dp[i] = query(arr[i].second - 1) + 1); update(arr[i].second, dp[i]); &#125; printf("%d\n", ans); &#125;&#125; int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大团 [搜索剪枝]]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%9C%80%E5%A4%A7%E5%9B%A2%2F</url>
    <content type="text"><![CDATA[方法这里的图都是指无向图。 给定一个图 $G = (V, E)$，如果有一个点集 $V’ \subseteq V$， 满足对于任意点对 $u, v \in V’$ 都有边 $(u, v) \in E$, 则成 $V’$ 对于 $G$ 的诱导子图 $G’$ 是 $G$ 的一个完全子图。 （诱导子图： 子图 $G’ = (V’, E’)$ 满足 $V’ \subseteq V$，$E’ = \{(u, v)|u,v \in V’, (u, v) \in E\}$） 简单来说，团就是 $G$ 的一个完全子图。 极大团： 如果一个团不被任意一个团所包含（即它不是任意一个团的真子集），则称这个团为 $G$ 的一个极大团。 最大团：极大团中点数最多的那个团。 最大独立集：一个无向图的独立集大小即为它补图（边的存在性取反）的最大团大小（其点集也相同） 因为求最大团是 $NP$ 问题，但是在 $n \leqslant 100$ 搜索+剪枝可以跑的非常快 (0.01s 以内) 一、先想到一个最简单的 $dfs$ 最开始的点集 $S = \{ i | 1 \leqslant i \leqslant n \}$ 1、从 $S$ 中取出来一个点 $x$，把 $S$ 中所有 $x$ 能访问到的点 放入集合 $S_1$，再将这个集合 $S_1$ 作为新的 $S$。 2、如果 $S$ 还有元素，重复操作 1，否则停止 $dfs$，这时候就找到了 $G$ 的一个完全子图。直到找到所有的完全子图。 二、试图优化 $dfs$ 我们让这个 $S$ 为当前枚举到的点和它后面所有的点。 这样，当某个 S 集合为空时，$dfs$ 结束，得到一个只用后面几个点构成的完全子图，并用它去更新只用后面几个点构成的最大团。退出当前 DFS，返回上层 DFS，接着找下一个完全子图，直到找完所有的完全子图。 三、试图剪枝 记当前取出来的点的个数为 $num$ 如果我们现在取出了 $S$ 中的一个元素 $x$，要将 $S$ 中 $x$ 后面与 $x$ 相连的点加入 $S_1$ 的时候，考虑： 剪枝1： 如果 $num + S$ 中剩下的元素个数 $\leqslant ans$ ， 剪枝 按照我们 $dfs$ 的方式，当选中编号为 $x$ 的点时，一定知道了 $[x + 1, n]$，$[x + 2, n]$， $\cdots$， $[n, n]$ 这些区间的点能构成的最大团的大小。记区间 $[x + 1, n]$ 的最大团的大小为 $mxsize[x + 1]$ 剪枝2：如果 $num + mxsize[x] \leqslant ans$ ，剪枝 剪枝3： 如果 $dfs$ 到了最底层，并且能够更新答案，就不要在 $dfs$ 了，结束 因为如果我们继续枚举 $dfs$，点的编号变大了，可用点变少（可用的点在一开始 $dfs$ 初始化的时候就确定了，随着不断的加深 $dfs$ 的层数，可用的点在不断的减少） 剪枝后真点跑的飞快 例题HDU 1530 Maximum CliqueVjudge-Link HDU-Link 模板题 upd 2.25 : 以前用的是vector，常数巨大，跑的巨慢，于是换成了数组 同一组数据：数组 3s，vector 45s，vector+O2 4.5s 1234567891011121314151617181920212223242526272829303132333435int best, G[N][N], mxsize[N], arr[N][N];bool dfs(const int sz, const int num)&#123; int *a = arr[num]; if (!sz) return best &lt; num ? best = num, true : false; for (int i = 1; i &lt;= sz; i++) &#123; if (num + sz - i + 1 &lt;= best || num + mxsize[a[i]] &lt;= best) return false; int tot = 0; for (int j = i + 1; j &lt;= sz; j++) if (G[a[i]][a[j]]) arr[num + 1][++tot] = a[j]; if (dfs(tot, num + 1)) return true; &#125; return false;&#125;void MC()&#123; best = 0; memset(mxsize, 0, sizeof(int[n + 1])); for (int i = n; i; i--) &#123; int tot = 0; for (int j = i + 1; j &lt;= n; j++) if (G[i][j]) arr[1][++tot] = j; dfs(tot, 1); mxsize[i] = best; &#125;&#125; HDU 3585Vjudge-Link HDU-Link 要求找出来 $k$ 个点，使得这 $k$ 个点中距离最远的两个点的距离最大。 二分答案， 根据 $mid$ 重新建图，判断条件是当前这个图的最大团大小是否大于等于 $k$ 参考资料https://www.cnblogs.com/zhj5chengfeng/p/3224092.html]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>最大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vector [计算几何]]]></title>
    <url>%2F2019%2F02%2F23%2FVector%2F</url>
    <content type="text"><![CDATA[话说我怎么总有一种抄了一段书的感觉……（本人使用，纯粹怕忘） 不知道为什么博客上 $\degree$ 会变成这样…… 记了一些计算几何里面会用到的一些很基础的东西，代码是抄的 lrj 大大的 定义12345678910111213141516const double eps = 1e-10;struct Point&#123; double x, y; Point(const double _x = 0, const double _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;typedef Point Vector; // 在实现上 Vector 只是 Point 的别名// 向量 + 向量 = 向量， 点 + 向量 = 点inline Vector operator + (const Vector &amp;A, const Vector &amp;B) &#123;return Vector(A.x + B.x, A.y + B.y);&#125;// 点- 点 = 向量inline Vector operator - (const Point &amp;A, const Point &amp;B) &#123;return Vector(A.x - B.x, A.y - B.y);&#125;// 向量 × 数值 = 向量inline Vector operator * (const Vector &amp;A, const double p) &#123;return Vector(A.x * p, A.y * p);&#125;// 向量 / 数值 = 向量inline Vector operator / (const Vector &amp;A, const double p) &#123;return Vector(A.x / p, A.y / p);&#125; 以及位置关系的比较函数 (不知道有啥用.jpg)12345678inline bool operator &lt; (const Point &amp;A, const Point &amp;B)&#123; return A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y);&#125;inline bool operator == (const Point &amp;A, const Point &amp;B)&#123; return fabs(A.x - B.x) &lt; eps &amp;&amp; fabs(A.y - B.y) &lt; eps;&#125; 基本运算点积两个向量 $v$ 和 $w$ 的点积等于二者长度的乘积再乘上它们夹角的余弦。 因为余弦函数是偶函数，因此点积满足交换律。当夹角 $&gt; 90$ 度 时点积为负，如果两向量垂直，则点积为 $0$。 在坐标系下，两个向量 $OA$ 和 $OB$ 的点积等于 $x_A x_B + y_A + y_B$ 1inline double Dot(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.x + A.y * B.y;&#125; 然后还可以偷个懒用点积算模长 （其实就是 $\sqrt{x^2 + y^2}$） 1inline double Length(const Vector &amp;A) &#123;return sqrt(Dot(A, A));&#125; 然后再利用 $\operatorname{acos}$ 函数求两向量的夹角大小，其中 $\operatorname{acos}$ 得到的是弧度制 1inline double Angle(const Vector &amp;A, const Vector &amp;B) &#123;return acos(Dot(A, B) / Length(A) / Length(B));&#125; 叉积两个向量 $v$ 和 $w$ 的叉积等于 $v$ 和 $w$ 组成的三角形的有向面积的两倍。 叉积不满足交换律，但是有 $cross(v, w) = -cross(w, v)$ 在坐标系下，两个向量 $OA$ 和 $OB$ 的叉积等于 $x_A y_B - y_A x_B$ 1inline double Cross(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.y - A.y * B.x;&#125; 有了叉积，自然可以算三角形的面积了，别忘了 $S_{ABC} = fabs(Area2(A, B, C)) / 2$ 1inline double Area2(const Point &amp;A, const Point &amp;B, const Point &amp;C) &#123;return Cross(B - A, C - A);&#125; 向量旋转向量可以绕起点旋转，公式为 $x’ = x \cos a - y \sin a$ ，$y’ = x \sin a - y \cos a$，其中 $a$ 为逆时针旋转的角（弧度） 1234inline Vector Rotate(const Vector &amp;A, double rad)&#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125; 特殊情况，计算向量的单位法线，即左转 $90$ 度 以后把长度归一化123456// 调用前请确保 A 不是零向量Vector Normal(const Vector &amp;A)&#123; double L = Length(A); return Vector(-A.y / L, A.x / L);&#125; 点和直线直线的参数表示直线可以用直线上一点 $P_0$ 和方向向量 $v$ 表示($v$ 的大小没有用)，直线上所有点 $P$ 满足 $P = P_0 + tv$ ，其中 $t$ 称为参数。例如，如果已知直线上的两个不同点 $A$ 和 $B$，则方向向量为 $B - A$，所以参数方程为 $A + (B - A)t$ 参数方程最方便的地方在于直线、射线和线段的方程形式是一样的，区别仅仅在于参数的范围，故很多对于直线适用的公式对于射线、线段依旧适用。 直线交点设直线分别为 $P + tv$ 和 $Q + tw$ ，设向量 $u = P - Q$，交点在直线一的参数为 $t_1$，交点在直线二的参数为 $t_2$，，解方程得 t_1 = \frac{cross(w, u)}{cross(v, w)} \ \ \ \ t_2 = \frac{cross(v, u)}{cross(v, w)}调用前请确保两条直线有唯一交点，当且仅当 $cross(v, w) \neq 0$ 123456inline Point GetLineIntersection(const Point &amp;P, const Vector &amp;v, const Point &amp;Q, const Vector &amp;w)&#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125; 点到直线距离利用叉积，平行四边形面积除以底即可 1234inline double DistanceToLink(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; return fabs(Cross(B - A, P - A)) / Length(B - A);&#125; 当然如果有了解析式（直线方程的一般式 $Ax + By + C = 0$ )，也可以利用高中数学的公式计算 d = \frac{\mid Ax_p + By_p + C \mid}{\sqrt{A^2 + B^2}}点到线段距离设投影点为 $Q$，分类讨论 $Q$ 在线段 $AB$ 上，则所求距离就是 $P$ 点与直线 $AB$ 的距离 $Q$ 在射线 $BA$ 上，则所求距离为 $dis(P, A)$ $Q$ 在射线 $AB$ 上，则所求距离为 $dis(P, B)$ 判断 $Q$ 的位置可以用点积进行（利用权值的正负） 12345678inline double DistanceToSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; if (A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if (Dot(v1, v2) &lt; 0) return Length(v2); // ∠PAB &gt; 90°，ans = dis(A, P) else if (Dot(v1, v3)) return Length(v3); // ∠PBA &gt; 90°，ans = dis(B, P) else return fabs(Cross(v1, v2)) / Length(v1); // 投影点在线段AB上&#125; 点在直线上的投影把直线 $AB$ 写成参数式 $A+tv$ 其中（向量 $v$ 是 $B - A$），并且设点 $Q$ 的参数为 $t_0$ ，那么 $Q = A + t_0v$ 。 根据 $PQ$ 垂直于 $Q$，两个向量的点积应该为 $0$，因此 $Dot(v, P- (A + t_0v)) = 0$ 根据分配率，有 $Dot(v, P - A) - t_0 \times Dot(v, v) = 0$ $t_0 = Dot(v, P - A) / Dot(v, v)$ 就可以求得 $t_0$ 了。 12345inline Point GetLineProjection(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125; 判断两条线段是否相交不允许在端点处相交：定义“规范相交”为：两线段恰好有一个公共点，并且不在任何一条线段的端点。即 。 方法：快速排斥+跨立实验 快速排斥：以 $A_1B_1$，$A_2B_2$ 为对角线的两个矩形相交 跨立实验：以一条线段为标准，另一条线段的两个端点在这条线段两侧(这里的“两侧”是指叉积的符号不同) 123456789inline bool SegmentProperIntersection(const Point &amp;A1, const Point &amp;B1, const Point &amp;A2, const Point &amp;B2)&#123; if (!(min(A1.x, B1.x) &lt;= max(A2.x, B2.x) &amp;&amp; min(A2.x, B2.x) &lt;= max(A1.x, B1.x) &amp;&amp; min(A1.y, B1.y) &lt;= max(A2.y, B2.y) &amp;&amp; min(A2.y, B2.y) &lt;= max(A1.y, A2.y))) return false; // 快速排斥 double c1 = Cross(A2 - A1, B1 - A1); double c2 = Cross(A2 - A1, B2 - A1); double c3 = Cross(B2 - B1, A1 - B1); double c4 = Cross(B2 - B1, A2 - B1); return c1 * c2 &lt; 0 &amp;&amp; c3 * c4 &lt; 0;&#125; 允许在端点处相交分类讨论 如果 $c_1$， $c_2$ 都是 $0$，两线段共线，可能有部分重叠的情况 如果 $c_1$， $c_2$ 都不是 $0$，则只有某个端点在两一条线段上这一种相交方法，为了判断上述情况是否发生，还需要判断一个点是否在一条线段上（不含端点），如下 1234inline bool OnSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B)&#123; return fabs(Cross(A - P, B - P)) &lt; eps &amp;&amp; Dot(A - P, B - P) &lt; 0;&#125; 也许还会接着补，说不定就咕咕咕了…… 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182namespace PointAndVector&#123; const double eps = 1e-10; struct Point &#123; double x, y; Point(const double _x = 0, const double _y = 0) : x(_x), y(_y) &#123;&#125; &#125;; typedef Point Vector; inline Vector operator + (const Vector &amp;A, const Vector &amp;B) &#123;return Vector(A.x + B.x, A.y + B.y);&#125; inline Vector operator - (const Vector &amp;A, const Vector &amp;B) &#123;return Vector(A.x - B.x, A.y - B.y);&#125; inline Vector operator * (const Vector &amp;A, const double p) &#123;return Vector(A.x * p, A.y * p);&#125; inline Vector operator / (const Vector &amp;A, const double p) &#123;return Vector(A.x / p, A.y / p);&#125; inline bool operator &lt; (const Point &amp;A, const Point &amp;B) &#123; return A.x &lt; B.x || (A.x == B.x &amp;&amp; A.y &lt; B.y); &#125; inline bool operator == (const Point &amp;A, const Point &amp;B) &#123; return fabs(A.x - B.x) &lt; eps &amp;&amp; fabs(A.y - B.y) &lt; eps; &#125; inline double Dot(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.x + A.y * B.y;&#125; inline double Length(const Vector &amp;A) &#123;return sqrt(Dot(A, A));&#125; inline double Angle(const Vector &amp;A, const Vector &amp;B) &#123;return acos(Dot(A, B) / Length(A) / Length(B));&#125; inline double Cross(const Vector &amp;A, const Vector &amp;B) &#123;return A.x * B.y - A.y * B.x;&#125; inline double Area2(const Point &amp;A, const Point &amp;B, const Point &amp;C) &#123;return Cross(B - A, C - A);&#125; inline Vector Rotate(const Vector &amp;A, double rad) &#123; return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad)); &#125; inline Point GetLineIntersection(const Point &amp;P, const Vector &amp;v, const Point &amp;Q, const Vector &amp;w) &#123; Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t; &#125; inline double DistanceToLink(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; return fabs(Cross(B - A, P - A)) / Length(B - A); &#125; inline double DistanceToSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; if (A == B) return Length(P - A); Vector v1 = B - A, v2 = P - A, v3 = P - B; if (Dot(v1, v2) &lt; 0) return Length(v2); else if (Dot(v1, v3)) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1); &#125; inline Point GetLineProjection(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v)); &#125; inline bool SegmentProperIntersection(const Point &amp;A1, const Point &amp;B1, const Point &amp;A2, const Point &amp;B2) &#123; if (!(min(A1.x, B1.x) &lt;= max(A2.x, B2.x) &amp;&amp; min(A2.x, B2.x) &lt;= max(A1.x, B1.x) &amp;&amp; min(A1.y, B1.y) &lt;= max(A2.y, B2.y) &amp;&amp; min(A2.y, B2.y) &lt;= max(A1.y, A2.y))) return false; double c1 = Cross(A2 - A1, B1 - A1); double c2 = Cross(A2 - A1, B2 - A1); double c3 = Cross(B2 - B1, A1 - B1); double c4 = Cross(B2 - B1, A2 - B1); return c1 * c2 &lt; 0 &amp;&amp; c3 * c4 &lt; 0; &#125; inline bool OnSegment(const Point &amp;P, const Point &amp;A, const Point &amp;B) &#123; return fabs(Cross(A - P, B - P)) &lt; eps &amp;&amp; Dot(A - P, B - P) &lt; 0; &#125;&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4652 [NOI2016] 循环之美 [杜教筛]]]></title>
    <url>%2F2019%2F02%2F22%2Fbzoj4652%2F</url>
    <content type="text"><![CDATA[题面bzoj4652luogu1587 给定正整数 $n$, $m$, $k$,求 $\frac{x}{y}$ 在 $k$ 进制下为纯循环小数的不同的的值的个数,其中 $x$, $y$ 为正整数且 $x \leqslant n,y \leqslant m$。 其中 $n, m \leqslant 10^9 ,k \leqslant 2000$。 纯循环：循环节从小数点后开始 分析首先要是既约分数，故有 $\gcd(x,y)=1$ 它是一个 $k$ 进制下纯循环小数的条件是存在 $x \times k^{\alpha} \equiv x \mod y$，即 $\gcd(k, y) = 1$ 证明： 非常感谢给我证了这个的兔子神仙！！！ 因为 $x \neq 0$ ，即要证 $k^a \equiv 1 \mod y$ 充分性: 根据鸽巢原理(咕巢原理)可得一定存在 $i$， $j$ ($i &lt; j$) 使得 $k^i \equiv k^j \mod y$ 因为 $(k,y)=1$，除过去可得 $k^{j-i} \equiv 1 \mod y$。 必要性: 首先有:当 $(a,b)=1$ 时，$(a^x,b)=1$ $k^a \equiv 1 \mod y$ 即 $k^a + b \times y = 1$，根据裴蜀定理可得$(k^a,y)=1$ 故可得只有当 $(k,y)=1$ 才有 $k^a \equiv 1 \mod y$ 裴蜀定理(推论): $a$, $b$ 互质的充要条件是存在整数$x$, $y$ 使 $ax+by=1$. 所以答案为 \sum_{x=1}^n \sum_{y=1}^m \epsilon(\gcd(x, y)) \epsilon(\gcd(y, k))然后就是愉悦的推式子环节 \begin{aligned} &= \sum_{x=1}^n \sum_{y=1}^m \sum_{d|x,d|y} \mu(d) [(y,k)=1] \\ &= \sum_{d=1}^n \mu(d) \sum_{x=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{y=1}^{\lfloor\frac{m}{d}\rfloor} [(yd,k)=1] \\ &= \sum_{d=1}^n [(d,k)=1] \mu(d) \lfloor\frac{n}{d}\rfloor \sum_{y=1}^{\lfloor\frac{m}{d}\rfloor} [(y,k)=1] \\ \end{aligned}记 $h(x) = [(x,k)=1]$, $S_h$表示 $h$ 的前缀和, 记 $f(x) = [(d,k)=1] \mu(d)$ = \sum_{d=1}^n f(d) \lfloor\frac{n}{d}\rfloor S(\lfloor\frac{m}{d}\rfloor)\\后面两个数论分块后就要求 $f$ 的前缀和,因为 $f = \mu \cdot h$, 要杜教筛还要找一个函数 $g$, 按照套路可得 $g=h$ f * h \\ \begin{aligned} &= (\mu \cdot h) * (1 \cdot h) \\ &= (\mu * 1) \cdot h \\ &= \epsilon \cdot h \end{aligned}因为 $h(1)=1$, 故 $\sum_{i=1}^n(f * h)(n) = [n \geqslant 1]$ 对于 $S_h$ , 有 $S_h(n) = \lfloor\frac{n}{k}\rfloor \varphi(k) + h(n \% k) = \lfloor\frac{n}{k}\rfloor h(k) + h(n \% k)$ 完结撒花~ 代码因为要有 $n$ 和 $m$ 的两个数论分块后的结果(要分开) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int K = 2010; const int N = 1000000; const int M = 1000; int n, m, k, S[K + 5], Pre[N + 5], Sum[2][M + 5]; int gcd(const int a, const int b) &#123; return !b ? a : gcd(b, a % b); &#125; void init() &#123; static int cnt, prime[N + 5], vis[N + 5], mu[N + 5]; mu[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!vis[i]) prime[++cnt] = i, mu[i] = -1; for (int j = 1, t; j &lt;= cnt &amp;&amp; (t = i * prime[j]) &lt;= N; j++) &#123; vis[t] = 1; if (!(i % prime[j])) &#123;mu[t] = 0;break;&#125; mu[t] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= k; i++) &#123; int t = (gcd(k, i) == 1); S[i] = S[i - 1] + t; Pre[i] = Pre[i - 1] + mu[i] * t; &#125; for (int i = k + 1; i &lt;= N; i++) Pre[i] = Pre[i - 1] + mu[i] * (gcd(i, k) == 1); &#125; inline int calc(const int x) &#123; return (x / k) * S[k] + S[x % k]; &#125; int GetSum(const int x, const int type) &#123; static bool vis[2][M + 5]; if (x &lt;= N) return Pre[x]; int t = (!type ? n : m) / x; if (!vis[type][t]) &#123; int res = 1; for (int l = 2, r; l &lt;= x; l = r + 1) &#123; r = x / (x / l); res -= (calc(r) - calc(l - 1)) * GetSum(x / l, type); &#125; Sum[type][t] = res; vis[type][t] = 1; &#125; return Sum[type][t]; &#125; void work() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); init(); GetSum(n, 0), GetSum(m, 1); ll ans = 0; int last = 0, now, lim = min(n, m); for (int l = 1, r; l &lt;= lim; l = r + 1) &#123; int t1 = n / (n / l), t2 = m / (m / l); now = GetSum((r = min(t1, t2)), t1 &gt; t2); ans = ans + (ll)(now - last) * (n / l) * calc(m / l); last = now; &#125; printf("%lld\n", ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4816 [SDOI2017]数字表格 [莫比乌斯反演]]]></title>
    <url>%2F2019%2F01%2F27%2Fbzoj4816%2F</url>
    <content type="text"><![CDATA[题目Luogu 3704Bzoj 4816 求 \prod_{i=1}^n \prod_{j=1}^m f[gcd(i, j)]其中 $f[i]$ 为 $Fibonacci$ 数列的第 $i$ 项。答案对 $10^9 + 7$ 取模。 分析首先肯定是要写暴力（要把自己摘出来），假定 $n \leqslant m$ 把 $Fibonacci$ 数列打出来，记 $times[d]$ 表示满足 $[gcd(i, j)] = d$ 的 $(i, j)$ 的对数，然后就有 times[d] = \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor - \sum_{i=1}^{n} times[i \times d]然后就有 $60$ 分了，不想写正解了快溜，复杂度 $O(T n log log n)$ 看到 $gcd$ 就想到莫比乌斯反演，令 $gcd(i, j) = d$ 推式子 \begin{aligned} & = \prod_{i=1}^n \prod_{j=1}^m \sum_{d=0}^n f[d] \ [gcd(i, j) = d] \\ & = \prod_{d=1}^n f[d]^{ \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{i=1}^{\lfloor \frac{m}{d} \rfloor} [gcd(i, j) = 1]} \end{aligned}提出次数，反演 \begin{aligned} & \ \ \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{i=1}^{\lfloor \frac{m}{d} \rfloor} [gcd(i, j) = 1] \\ & = \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{i=1}^{\lfloor \frac{m}{d} \rfloor} \sum_{g|gcd(i,j)} \mu(g) \\ & = \sum_{g=1}^{\lfloor \frac{n}{d} \rfloor} \mu(g) \lfloor \frac{n}{dg} \rfloor \lfloor \frac{m}{dg} \rfloor \end{aligned}令 $T = dg$ = \mu (\frac{T}{d}) \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$ 可以数论分块了，提出来，带回原式 \begin{aligned} &=\prod_{d=1}^n f[d]^{\sum_{g=1}^{\lfloor \frac{n}{d} \rfloor} \mu(g) \lfloor \frac{n}{dg} \rfloor \lfloor \frac{m}{dg} \rfloor} \\ &=\prod_{T=1}^n \left( \prod_{d|T} f[d]^{\mu(\frac{T}{d})} \right)^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor} \end{aligned}令 $F(T) = \prod_{d|T} f[d]^{\mu(\frac{T}{d})}$ =\prod_{T=1}^n F(T)^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}然后如果可以预处理 $F(T)$，那么直接数论分块就可以了。 预处理可以直接刷表，枚举 $d$ 和 $d$ 的倍数，$O(n log log n)$ 预处理即可。 复杂度应该没有问题吧 代码这个是 $60$ 分的暴力，空格好哇12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1e6 + 10; const int p = 1e9 + 7; const int Phi = 1e9 + 6; int f[N], times[N]; inline int read() &#123; int x = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return x; &#125; #define Mod(x) (x) &gt;= p ? (x) - p : (x) inline ll qpow(ll x, ll tim) &#123; ll ans = 1; for (; tim; tim &gt;&gt;= 1, x = x * x % p) if (tim &amp; 1) ans = ans * x % p; return ans; &#125; void work() &#123; f[0] = 0, f[1] = 1; for (int i = 2; i &lt;= 1000000; i++) f[i] = Mod(f[i - 1] + f[i - 2]); int T = read(); while (T--) &#123; int n = read(), m = read(), mn = min(n, m); memset(times, 0, sizeof(int[mn + 1])); for (int i = mn; i; i--) &#123; times[i] = (ll)(n / i) * (m / i) % Phi; for (int j = i + i; j &lt;= mn; j += i) times[i] = (times[i] - times[j] + Phi) % Phi; &#125; ll ans = 1LL; for (int i = 1; i &lt;= mn; i++) ans = ans * qpow(f[i], times[i])% p; printf("%lld\n", ans); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; Accepted123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int N = 1e6; const int p = 1e9 + 7; int f[N + 5], F[N + 5], mu[N + 5]; inline int read() &#123; int x = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return x; &#125; #define Mod(x) (x) &gt;= p ? (x) - p : (x) inline ll qpow(ll x, ll tim) &#123; if (tim &lt; 0) tim += p - 1; ll ans = 1; for (; tim; tim &gt;&gt;= 1, x = x * x % p) if (tim &amp; 1) ans = ans * x % p; return ans; &#125; void get_mu() &#123; static int cnt, prime[N], vis[N + 5]; mu[1] = 1; for (int i = 2; i &lt;= N; i++) &#123; if (!vis[i]) prime[++cnt] = i, mu[i] = -1; for (int j = 1, k; j &lt;= cnt &amp;&amp; (k = i * prime[j]) &lt;= N; j++) &#123; vis[k] = 1; if (i % prime[j] == 0) break; mu[k] = -mu[i]; &#125; &#125; &#125; void init() &#123; f[0] = 0, f[1] = 1; for (int i = 2; i &lt;= N; i++) f[i] = Mod(f[i - 1] + f[i - 2]); get_mu(); static int arr[3]; for (int i = 0; i &lt;= N; i++) F[i] = 1; for (int i = 1; i &lt;= N; i++) &#123; arr[0] = qpow(f[i], -1); arr[2] = f[i]; for (int j = i; j &lt;= N; j += i) if (mu[j / i]) F[j] = (ll)F[j] * arr[mu[j / i] + 1] % p; &#125; for (int i = 2; i &lt;= N; i++) F[i] = (ll)F[i - 1] * F[i] % p; &#125; void work() &#123; init(); int T = read(); while (T--) &#123; int n = read(), m = read(); if(n &gt; m) swap(n, m); ll ans = 1; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ll inv = qpow(F[l - 1], p - 2); ans = ans * qpow(F[r] * inv % p, (ll)(n / l) * (m / l) % (p - 1)) % p; &#125; printf("%lld\n", ans); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4566 [HAOI2016]找相同字符 [SAM]]]></title>
    <url>%2F2019%2F01%2F12%2Fbzoj4566%2F</url>
    <content type="text"><![CDATA[写在前面写这篇题解的原因纯粹是 zyt 神仙的方法太麻烦了 题目luogu 3181 bzoj 4566 给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。 $1 \leqslant length \leqslant 200000$ 方法可以直接跳到“简单来说” 对于有多个串的问题，我们可以建广义 $SAM$，但是实际上没有什么必要，可以将每两个串之间用一个奇怪的字符（例如 $’a’+26$）全部连起来，变成一个串，对于这个串建 $SAM$。 然后可以发现，如果这两个串有一个子串相同，那么这个子串在 $SAM$ 上对应的是同一个节点。我们转化一下，如果 $SAM$ 上的一个节点在串 $A$ 中的 $right$ 集合大小为 $a$，在串 $B$ 中的 $right$ 集合大小为 $b$，那么 $a$ ，$b$ 中任意两个配对都是一个合法的情况（即子串相同）。 又因为要求是本质不同的子串，$SAM$ 上每个节点代表了长度在 $[minlen,maxlen]$ 之间的相同的子串，故每个点的贡献还要乘上 $maxlen-minlen+1$。 简单来说，连接串 $A$，$B$ 建在一个 $SAM$ 上，如果用 $tot$ 表示 $SAM$ 的点数， $size[i][0/1]$ 表示 $SAM$ 上节点 $i$ 中包含的串 $A$ 或 $B$ 的 $right$ 集合的大小，$mx[i]$ 表示点 $i$ 的 $maxlen$，那么 ans=\sum_{i=1}^{tot} size[i][0] \times size[i][1] \times (mx[i] - mx[fa[i]])代码代码写起来就是 $SAM$ 的基础操作：插入和基数排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=800010; long long ans; namespace SAM &#123; int last=1,tot=1,size[N][2]; struct node &#123; int fa,mx,son[27]; &#125;tr[N]; void insert(const int c,const int id) &#123; int now=++tot,p=last; tr[now].mx=tr[p].mx+1; if(id!=2) size[now][id]++; while(p&amp;&amp;!tr[p].son[c]) tr[p].son[c]=now,p=tr[p].fa; if(!p) tr[now].fa=1; else &#123; int q=tr[p].son[c]; if(tr[q].mx==tr[p].mx+1) tr[now].fa=q; else &#123; int clone=++tot; tr[clone]=tr[q]; tr[clone].mx=tr[p].mx+1; tr[q].fa=tr[now].fa=clone; while(p&amp;&amp;tr[p].son[c]==q) tr[p].son[c]=clone,p=tr[p].fa; &#125; &#125; last=now; &#125; void radix_sort() &#123; static int bask[N],q[N]; for(int i=1;i&lt;=tot;i++) bask[tr[i].mx]++; for(int i=1;i&lt;=tot;i++) bask[i]+=bask[i-1]; for(int i=tot;i;i--) q[bask[tr[i].mx]--]=i; for(int i=tot;i&gt;1;i--) &#123; int now=q[i],f=tr[now].fa; size[f][0]+=size[now][0]; size[f][1]+=size[now][1]; ans+=(long long)size[now][0]*size[now][1]*(tr[now].mx-tr[f].mx); &#125; &#125; &#125; void work() &#123; static char s[N&gt;&gt;1]; scanf("%s",s); int len=strlen(s); for(int i=0;i&lt;len;i++) SAM::insert(s[i]-'a',0); SAM::insert(26,2); scanf("%s",s); len=strlen(s); for(int i=0;i&lt;len;i++) SAM::insert(s[i]-'a',1); SAM::radix_sort(); printf("%lld",ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有上下界的网络流/费用流 学习笔记 [网络流]]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%26%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[安利博客 liu_runda 有上下界的网络流，顺便抄一段话 有上下界的网络流的核心是”调整”,我们通过一个初始的未必可行的流调整出一个可行流,还可以从可行的未必最大/最小的流调整出最大/最小。另一个常用技巧是有源汇的流和无源汇的流(循环流)的转换。除了无源汇可行流的求解,其他有源汇的上下界网络流都要用到这个技巧。 无源汇上下界可行流 （循环流）模型给定一个网络，求一个流，满足每条边的流量都 $min \leqslant flow \leqslant max$ ，并且每个点都满足 总流入量=总流出量（流量守恒） ，没有源汇。 核心思想将一个不满足流量守恒的初始流调整成满足流量守恒的流。 方法如果存在一个可行流，它一定满足每条边的流量都大于等于下界。那么我们可以先令每条边的流量等于它的下界，得到一个初始流，然后建出这个流的残余网络（每条边流量为上下界之差）。初始流不一定满足流量守恒，我们要做的就是通过增加某些边的流量使它流量守恒来得到一个可行流。 我们将之后扩大流量的流叫做附加流，初始流合并附加流就是可行流。那么，为达到流量守恒，一定存在： 如果一个点在初始流中满足流量守恒，那么它在附加流中也满足流量守恒 如果一个点在初始流中的流入量比流出量多 $x$ ，那么它在附加流中流出量比流入量少 $x$ 如果一个点在初始流中的流入量比流出量少 $x$ ，那么它在附加流中流出量比流入量多 $x$ 我们用 $d[i]$ 表示点 $i$ 在初始流中流入量-流出量的值，那么 $d[i]$ 的正负就可以表示以上三种情况。 如果一个点$d[i] &lt; 0$，我们需要给多出的流入量一个出处，需要让附加流中 $i$ 的流入量比流出量少 $-d[i]$，所以建一条从 $i$ 出发的边，流量为 $-d[i]$；如果 $d[i] &gt; 0$，则建一条指向 $i$ 的边，流量为$d[i]$。 虚拟源汇点 $s$，$t$。分类 \left\{ \begin{aligned} d[i] > 0 & \ \ \ \ 建 s 指向 i 的边，使附加流中 i 的流出量增加 d[i] \\ d[i] < 0 & \ \ \ \ 建 i 指向 t 的边，使附加流中 i 的流入量增加 -d[i] \\ \end{aligned} \right.为了得到一个可行流，指向 $t$ 的边的总流量上限必须等于从 $s$ 出发的边的总流量上限，因为原图上每条边对两个端点的 $d[i]$ 的贡献一正一负绝对值相同，所以 $\sum_{i=1}^n d[i] = 0$，并且 \sum_{d[i]0} |d[i]|除了连接 $s$，$t$ 的边以外，在连上原图中的边，流量为上界-下界。在这个图上，如果我们能够找到一个流满足所有连接 $s$，$t$ 的边都满流，那这个流在原图中边上的流量就是我们要的附加流。这样的流就是我们所建的新图中 $s$ 到 $t$ 的最大流。 存在可行流的条件：$s$ 到 $t$ 的最大流 = $\sum_{d[i]&gt;0} d[i]$ 最后，每条边的流量 = 下界 + 附加流中它的流量 例题ZOJ2314 Reactor Cooling 求是否存在一个无源汇可行流，若存在，输出每条边的流量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=210; const int M=40010; const int inf=0x3f3f3f3f; int n,m,cnt,s,t,Head[N],d[N],dep[N],low[M],cur[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w; &#125;E[M&lt;&lt;1]; inline void add(const int u,const int v,const int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; E[++cnt]=(edge)&#123;u,Head[v],0&#125;; Head[v]=cnt; &#125; void init() &#123; s=n+1,t=s+1,cnt=1; memset(d,0,sizeof(int[n+1])); memset(Head,0,sizeof(int[t+1])); &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(dep,0,sizeof(int[t+5])); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!dep[v]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]; &#125; int dfs(const int u,const int mn) &#123; if(u==t||!mn) return mn; int v,w,used=0; for(int i=Head[u];i;i=E[i].next) &#123; v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(E[i].w,mn-used)); used+=w; E[i].w-=w,E[i^1].w+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; inline int Dinic() &#123; int ans=0; while(bfs()) ans+=dfs(s,inf); return ans; &#125; void work() &#123; int T=read(); while(T--) &#123; n=read(),m=read(); init(); for(int i=1;i&lt;=m;i++) &#123; int x=read(),y=read(),l=read(),u=read(); add(x,y,u-l); low[i]=l; d[x]-=l,d[y]+=l; &#125; int tot=0,last=cnt; for(int i=1;i&lt;=n;i++) &#123; if(d[i]&lt;0) add(i,t,-d[i]); else if(d[i]&gt;0) tot+=d[i],add(s,i,d[i]); &#125; if(Dinic()!=tot) puts("NO"); else &#123; puts("YES"); for(int i=3;i&lt;=last;i+=2) printf("%d\n",low[i&gt;&gt;1]+E[i].w); &#125; puts(""); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 有源汇的上下界可行流模型给定一个有源点 $s$ 和汇点 $t$ 的网络，求出一个源点流出量=汇点流入量，其它点流量守恒的的流，并且每条边满足上下界限制。 方法发现只有源汇点流量不守恒，那么我们建一条从 $t$ 到 $s$ 的边上界为 $inf$ 下界为 $0$，把 $t$ 的流出量流入 $s$ 使它俩守恒，就变成了一个无源汇可行流了。 如果是虚拟的源汇点不连可行流的虚拟源汇点 求完后，边 $(t-&gt;s)$ 的流量就是源汇点的流量（整个网络的流量）。 代码参见最小流的部分 有源汇的上下界最大流模型在上个模块条件下要求总流量最大 方法上面那个求出来的是可行流，不一定最大，我们在残余网络上跑 $s$ 到 $t$ 的最大流即可。 最大流=可行流流量（ $t-&gt;s$ 边的流量）+ 新增广的 $s$ 到 $t$ 的最大流 注意 这里的 $s$，$t$是原图中给定的源汇点，不是求可行流时虚拟的源汇点。 要先删除了那两个虚拟的源汇点（删掉和它相连的边）和新加的边 $(t-&gt;s)$ （即将边权设为0）再算！！ 感觉没啥给代码的必要……（可以参见最小流） 有源汇的上下界最小流模型在上上一个模块条件要求下，总流量最小 方法先跑有源汇可行流，然后在残余网络上跑 $t$ 到 $s$ 的最大流，这样实际上消耗的图中的反向边，反向边流量的减少就是总流量的减少，即缩减流量。 最小流=可行流流量（ $t-&gt;s$ 边的流量）- 减去的 $t$ 到 $s$ 的最大流 因为这些边的下界并没有在图中建出，即无论怎么减少，只要边的流量还是 $\leqslant 0$ 的，它就依旧满足流量下界。 例题bzoj2502 清理雪道luogu4843 清理雪道 画个图一看数据范围这么小，这不就是个流嘛，将总部看作源点，源点可以到达任意点；再将结束看作汇点，任意点都可以到汇点。然后要求每条边至少走一次，那就是边的流量有下界为1，没有上界，求最小次数直接跑有源汇上下界最小流就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=110; const int M=10010; const int inf=0x3f3f3f3f; int n,s,t,cnt=1,Head[N],d[N],deg[N],cur[N],dep[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w; &#125;E[M&lt;&lt;2]; inline void add(const int u,const int v,const int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; E[++cnt]=(edge)&#123;u,Head[v],0&#125;; Head[v]=cnt; &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(dep,0,sizeof(int[t+5])); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!dep[v]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]; &#125; int dfs(const int u,const int mn) &#123; if(u==t||!mn) return mn; int v,w,used=0; for(int i=Head[u];i;i=E[i].next) &#123; v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(E[i].w,mn-used)); used+=w; E[i].w-=w,E[i^1].w+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; inline int Dinic() &#123; int ans=0; while(bfs()) ans+=dfs(s,inf); return ans; &#125; void work() &#123; n=read(); int ss=n+1,tt=n+2; s=n+3,t=n+4; for(int u=1;u&lt;=n;u++) &#123; int k=read(); while(k--) &#123; int v=read(); add(u,v,inf); d[u]--,d[v]++; &#125; &#125; for(int i=1;i&lt;=n;i++) add(ss,i,inf),add(i,tt,inf); add(tt,ss,inf); int ed=cnt; for(int i=1;i&lt;=n;i++) if(d[i]&gt;0) add(s,i,d[i]); else if(d[i]&lt;0) add(i,t,-d[i]); Dinic(); int flow=E[ed].w; for(int i=Head[s];i;i=E[i].next) E[i].w=E[i^1].w=0; for(int i=Head[t];i;i=E[i].next) E[i].w=E[i^1].w=0; E[ed-1].w=E[ed].w=0;//一定要删了后来加的边 s=tt,t=ss;//跑t-&gt;s的最大流 printf("%d\n",flow-Dinic()); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 因为实在是害怕不小心咕咕咕以至于忘了这码子事（忘到猴年马月），所以今天继续把费用流补上 无源汇上下界最小/大费用可行流模型在无源汇上下界可行流的基础上，要求费用最小。 方法同可行流一样，首先先将下界作为初始流（当然要把费用加上），然后按照上面一样的建图方法，就是边加上费用，其中新加的连接虚拟源汇的边费用为 $0$，跑费用流，得到的就是附加流的最小费用，加上初始流费用就是答案。 有源汇上下界最小/大费用可行流模型懒得说了，懂得 方法一样一样，连 $(t-&gt;s)$、上界 $inf$、费用 $0$ 的边，然后就可以跑无源汇上下界最小/大费用可行流了。 例题luogu 4043 [AHOI2014/JSOI2014]支线剧情bzoj 3876 [Ahoi2014&amp;Jsoi2014]支线剧情 给你一个有向无环图，每条边有一个费用，要求覆盖所有路径的条件下费用和最小。 看到路径覆盖自然网络流，配合费用就是费用流。然后路径覆盖就是每条边有一个下界为 $1$，没有上界，有源点 $1$ ，就变成了有源汇上下界最小费用可行流了，贴板贴板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=310; const int M=900010; const int inf=0x3f3f3f3f; int n,s,t,ans,Head[N],dis[N],vis[N],d[N],pre[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w,c; &#125;E[M&lt;&lt;1]; inline void add(const int u,const int v,const int w,const int c) &#123; static int cnt=1; E[++cnt]=(edge)&#123;v,Head[u],w,c&#125;; Head[u]=cnt; E[++cnt]=(edge)&#123;u,Head[v],0,-c&#125;; Head[v]=cnt; &#125; bool spfa() &#123; queue&lt;int&gt; q; memset(dis,inf,sizeof(int[t+1])); memset(pre,0,sizeof(int[t+1])); dis[s]=0,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); vis[u]=0; for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;dis[v]&gt;dis[u]+E[i].c) &#123; dis[v]=dis[u]+E[i].c; pre[v]=i; if(!vis[v]) vis[v]=1,q.push(v); &#125; &#125; &#125; return pre[t]; &#125; void mcmf() &#123; while(spfa()) &#123; int mn=inf; for(int i=pre[t];i;i=pre[E[i^1].to]) mn=min(mn,E[i].w); for(int i=pre[t];i;i=pre[E[i^1].to]) E[i].w-=mn,E[i^1].w+=mn; ans+=mn*dis[t]; &#125; &#125; void work() &#123; n=read(),s=n+2,t=s+1; for(int i=1;i&lt;=n;i++) &#123; int k=read(); d[i]-=k; while(k--) &#123; int j=read(),val=read(); d[j]++,ans+=val; add(i,j,inf,val); &#125; &#125; for(int i=2;i&lt;=n;i++) add(i,n+1,inf,0); add(n+1,1,inf,0); for(int i=1;i&lt;=n;i++) if(d[i]&gt;0) add(s,i,d[i],0); else add(i,t,-d[i],0); mcmf(); printf("%d\n",ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 完结撒花~]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小割树 学习笔记 [网络流]]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[问题luogu 4897 [模板] 最小割树（Gomory-Hu Tree） 给定一个 $n$ 个点 $m$ 条边的无向连通图，多次询问两点之间的最小割。 其中两点间的最小割是这样定义的：原图的每条边有一个割断它的代价，你需要用最小的代价使得这两个点不连通 $n \leqslant 500$， $m \leqslant 1500$ ，$q \leqslant 10^5$ 方法emmm……不证明的话很简单 首先有一个定理，就是一个n个点的图上，两点之间只有n种本质不同的最小割。因此一定存在一棵树，满足树上两点的最小割等于原图上两点的最小割。我们把这样的树称之为“最小割树”。 —Ebola 证明自然是没有的 在这里直接说建树方法，主要思想:分治 在图（当前点集）中任意选出来两个点 $s$ ，$t$，求出全图最小割 $flow(s,t)$，通过这条割将全图分成了两个连通块，其中 $s$ 所在的记作 $S$，$t$ 所在的记作 $T$。 引理： 对于任意的 $u \in S$，$v \in T$ ，都有 $flow(u,v) \leqslant flow(s,t)$ 证明：如果不存在，则 $flow(s,t)$ 不足以割开 $s$ 和 $t$，因为 $u$，$v$ 依旧相连。 我们在最小割树上连一条 $s$，$t$ 之间的边，边权为 $flow(s,t)$。然后再对 $S$ 和 $T$ 集合分治处理即可（做法同上）。 这样，我们分开 $n$ 个点跑了 $n$ 次网络流，建了 $n-1$ 条边，建成了一棵树，即最小割树。 时间复杂度 $n$ 次网络流 -&gt; $O(n^3 m)$，但是由于 $Dinic$ 时间复杂度比较玄学（反正我不知道），跑不满，能过。 因为是对全图的网络流（不是残余网络），所以每次网络流前要先回复其（最大）流量 12for(int i=2;i&lt;=cnt;i++) E[i].w=E[i^1].w=(E[i].w+E[i^1].w)&gt;&gt;1; 用处自然是可以快速求出两点之间最小割的。 引理：对于图上两点 $u$，$v$，他们之间的最小割是他们在最小割树的路径上的边权最小值 求树上两点路径上边权的最小值，倍增和树剖都可以。 当然！因为点数相当的少（不然用不了），完全可以 $O(n^2)$ 处理后 做到 O(1) 查询 懒人专用 代码这模板咋 $500ms$ …… $O2$ 好哇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=510; const int M=1510; const int inf=0x3f3f3f3f; int s,t,n,m,cnt=1,Head[N],tmp[N],cur[N],arr[N],vis[N],dep[N],flow[N][N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline void write(int x) &#123; int len=0;static int bask[50]; do bask[++len]=x%10,x/=10; while(x); while(len) putchar('0'+bask[len--]); putchar('\n'); &#125; struct edge &#123; int to,next,w; &#125;E[M&lt;&lt;1]; inline void add(const int u,const int v,const int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(dep,0,sizeof(int[n+1])); memcpy(cur,Head,sizeof(int[n+1])); dep[s]=1,q.push(s); while(!q.empty()) &#123; int u=q.front();q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!dep[v]) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]; &#125; int dfs(const int u,const int mn) &#123; if(u==t||!mn) return mn; int v,w,used=0; for(int &amp;i=cur[u];i;i=E[i].next) &#123; v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(mn-used,E[i].w)); used+=w; E[i].w-=w,E[i^1].w+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; inline int Dinic() &#123; int ans=0; while(bfs()) ans+=dfs(s,inf); return ans; &#125; void search(const int u) &#123; vis[u]=1; for(int i=Head[u];i;i=E[i].next) if(E[i].w&amp;&amp;!vis[E[i].to]) search(E[i].to); &#125; void solve(const int l,const int r) &#123; if(l==r) return; s=arr[l],t=arr[r]; for(int i=2;i&lt;=cnt;i+=2) E[i].w=E[i+1].w=(E[i].w+E[i+1].w)&gt;&gt;1; int f=Dinic(); memset(vis,0,sizeof(int[n+1])); search(s); for(int i=1;i&lt;=n;i++) if(vis[i]) for(int j=1;j&lt;=n;j++) if(!vis[j]) flow[i][j]=flow[j][i]=min(flow[i][j],f); int t1=l,t2=r; for(int i=l;i&lt;=r;i++) if(vis[arr[i]]) tmp[t1++]=arr[i]; else tmp[t2--]=arr[i]; memcpy(arr+l,tmp+l,sizeof(int[r-l+1])); solve(l,t1-1),solve(t2+1,r); &#125; void work() &#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(),w=read(); add(u,v,w),add(v,u,w); &#125; for(int i=1;i&lt;=n;i++) arr[i]=i; memset(flow,inf,sizeof(flow)); solve(1,n); int q=read(); while(q--) write(flow[read()][read()]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 例题[ZJOI2011] 最小割luogu3329 bzoj2229 好像很多人用的都是二分+网络流，如果你知道最小割树的话，就可以用 $floyd$ 求出两点最小割之后直接查询了 so easy! 代码代码是以前写的了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;namespace TYC&#123; const int MAXN=310,inf=0x3f3f3f3f; int n,m,cnt,s,t,Head[MAXN],vis[MAXN],a[MAXN],cur[MAXN],dep[MAXN],flow[MAXN][MAXN],tmp[MAXN]; inline int read() &#123; int x=0,f=0; char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int to,next,w; &#125;E[2000010]; void add(int u,int v,int w) &#123; E[++cnt]=(edge)&#123;v,Head[u],w&#125;; Head[u]=cnt; &#125; void init() &#123; cnt=1; memset(Head,0,sizeof(Head)); for(int i=1;i&lt;=150;i++) for(int j=1;j&lt;=150;j++) flow[i][j]=inf; &#125; void clear() &#123; for(int i=2;i&lt;=cnt;i++) E[i].w=E[i^1].w=(E[i].w+E[i^1].w)&gt;&gt;1; &#125; bool bfs() &#123; memset(dep,-1,sizeof(dep)); queue&lt;int&gt; q; dep[s]=0; q.push(s); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;dep[v]==-1) dep[v]=dep[u]+1,q.push(v); &#125; &#125; return dep[t]!=-1; &#125; int dfs(int u,int mn) &#123; if(u==t) return mn; int w,used=0; for(int &amp;i=cur[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; w=dfs(v,min(mn-used,E[i].w)); E[i].w-=w,E[i^1].w+=w; used+=w; if(used==mn) return used; &#125; &#125; if(!used) dep[u]=-1; return used; &#125; int Dinic() &#123; int ans=0; while(bfs()) &#123; memcpy(cur,Head,sizeof(cur)); ans+=dfs(s,inf); &#125; return ans; &#125; void dfs1(int u) &#123; vis[u]=1; for(int i=Head[u];i;i=E[i].next) &#123; int v=E[i].to; if(E[i].w&amp;&amp;!vis[v]) dfs1(v); &#125; &#125; void solve(int l,int r) &#123; if(l==r) return; s=a[l],t=a[r]; clear(); int f=Dinic(); //Tree: add_edge(s,t,f) 如果要建树 memset(vis,0,sizeof(vis)); dfs1(s); for(int i=1;i&lt;=n;i++) if(vis[i]) for(int j=1;j&lt;=n;j++) if(!vis[j]) flow[i][j]=flow[j][i]=min(flow[i][j],f); int L=l,R=r; for(int i=l;i&lt;=r;i++) if(vis[a[i]]) tmp[L++]=a[i]; else tmp[R--]=a[i]; for(int i=l;i&lt;=r;i++) a[i]=tmp[i]; solve(l,L-1),solve(R+1,r); &#125; void work() &#123; int T=read(); while(T--) &#123; init(); n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(),w=read(); add(u,v,w),add(v,u,w); &#125; for(int i=1;i&lt;=n;i++) a[i]=i; solve(1,n); int q=read(); while(q--) &#123; int x=read(),ans=0; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if(flow[i][j]&lt;=x) ans++; printf("%d\n",ans); &#125; puts(""); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 参考资料UranusITS的博客-最小割树]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2534 L-gap字符串 [SAM] [线段树] [启发式合并]]]></title>
    <url>%2F2019%2F01%2F08%2Fbzoj2534%2F</url>
    <content type="text"><![CDATA[题意bzoj2534 给你一个字符串 $S$，以及一个 $L$。 求 $S$ 中有多少个形如 $uvu$ 的子串，其中 $u$ 非空，且 $v$ 的长度恰好为 $L$。 其中 $len(S) \leqslant 50000$ ，$L \leqslant 10$。 分析讲道理数据里面居然全是大写字母 总感觉自己YY出来了什么神奇的东西，网上好像用 $SA$ 的比较多。 看到字符串第一个想 $SAM$ （被我校 $SAM$ 之神兔子教坏了） 考虑对于一个某个点 $now$ 的 $right$ 集合中的一个元素 $k$ ，它所能产生的贡献是在区间 $[k-L-mx[now],k-L-1]$ 或者 $[k+L+1,k+L+mx[now]]$ 并且在这个点的 $right$ 的集合中的点的个数 （$k-L-1$ 保证 $u$ 不为空）。 因为合并 $right$ 集合的时候，每一个点对仅会出现一次（或者说产生一次贡献），所以区间并不是在 $now$ 的长度 $[min,max]$ 之间，而是任意可行的长度 ($u$ 相同，即 $max$ 以内），因为在这个长度范围内的都是合法，并且下次不会被重复算到（合并后就不会再枚举到这个点对了）。 相当于两个右端点在 $parent$ 树上的 $LCA$ 处计算贡献。 那么就很简单了，建 $SAM$ 用线段树维护 $right$ 集合（用于求区间中点的个数），启发式合并，合并的时候统计 $y$ 合并入 $x$ 时 $y$ 中的点与 $x$ 中的点的贡献。 因为比较懒，所以再用了一个 $set$ 辅助启发式合并。 写完了感觉很奇怪因为并没有用到 $L \leqslant 10$ 这个条件…… 代码不要忘了左右两个区间都行，启发式合并交换 $set$ 的时候不要忘了交换线段树的根（合并了就可以扔掉 $y$ 了） 因为线段树启发式合并是 $O(n log^2 n)$ 的，所以空间也要开到 $O(n log^2 n)$ 。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; char s[50010];int n,L; long long ans; namespace Tree &#123; const int M=50000*70+10; int cnt,ls[M],rs[M],val[M]; void insert(int &amp;root,const int l,const int r,const int pos) &#123; if(!root) root=++cnt; ++val[root]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(ls[root],l,mid,pos); else insert(rs[root],mid+1,r,pos); &#125; int query(const int root,const int l,const int r,const int s,const int e) &#123; if(!root) return 0; if(s&lt;=l&amp;&amp;r&lt;=e) return val[root]; int mid=(l+r)&gt;&gt;1,ans=0; if(s&lt;=mid) ans+=query(ls[root],l,mid,s,e); if(e&gt;mid) ans+=query(rs[root],mid+1,r,s,e); return ans; &#125; &#125; namespace SAM &#123; const int N=100010; int last=1,tot=1,root[N]; struct node &#123; int fa,mx,son[26]; &#125;tr[N]; set&lt;int&gt; right[N]; typedef set&lt;int&gt;::iterator iter; void insert(const int c,const int pos) &#123; int now=++tot,p=last; tr[now].mx=tr[p].mx+1; right[now].insert(pos); Tree::insert(root[now],1,n,pos); while(p&amp;&amp;!tr[p].son[c]) tr[p].son[c]=now,p=tr[p].fa; if(!p) tr[now].fa=1; else &#123; int q=tr[p].son[c]; if(tr[q].mx==tr[p].mx+1) tr[now].fa=q; else &#123; int clone=++tot; tr[clone]=tr[q]; tr[clone].mx=tr[p].mx+1; tr[q].fa=tr[now].fa=clone; while(p&amp;&amp;tr[p].son[c]==q) tr[p].son[c]=clone,p=tr[p].fa; &#125; &#125; last=now; &#125; void merge(const int x,const int y) &#123; if(right[x].size()&lt;right[y].size()) right[x].swap(right[y]),swap(root[x],root[y]); for(iter it=right[y].begin();it!=right[y].end();it++) &#123; int l=max(1,*it-L-tr[x].mx),r=min(n,*it-L-1); if(l&lt;=r) ans+=Tree::query(root[x],1,n,l,r); l=*it+L+1,r=min(n,*it+L+tr[x].mx); if(l&lt;=r) ans+=Tree::query(root[x],1,n,l,r); &#125; for(iter it=right[y].begin();it!=right[y].end();it++) &#123; Tree::insert(root[x],1,n,*it); right[x].insert(*it); &#125; &#125; void radix_sort() &#123; static int bask[N],q[N]; for(int i=1;i&lt;=tot;i++) bask[tr[i].mx]++; for(int i=1;i&lt;=tot;i++) bask[i]+=bask[i-1]; for(int i=tot;i;i--) q[bask[tr[i].mx]--]=i; for(int i=tot;i;i--) merge(tr[q[i]].fa,q[i]); &#125; &#125; void work() &#123; scanf("%d%s",&amp;L,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;i++) SAM::insert(s[i]-'A',i); SAM::radix_sort(); printf("%lld\n",ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>线段树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkCutTree动态树 学习笔记 [数据结构]]]></title>
    <url>%2F2019%2F01%2F05%2FLinkCutTree%2F</url>
    <content type="text"><![CDATA[upd in 2019.1.8 ： 真是震惊极了……我打了这么久的板子（包括网上某些LCT讲解中的代码）竟然复杂度是假的！！！ 因为 splay 的复杂度是均摊的，每一次从根遍历了一条链就要将链尾 splay 上去（例如，如果当前的 splay 树形是一条长为 $n$ 递增的链-&gt;最大点为根，$m$ 次查询，每次查询第一个，如果不这样复杂度就变成 $O(mn)$ 了），才能保证复杂度均摊 $O(log n)$ 所以，在 $findroot$ 后，应当将最后的 $x$ splay 到根。 别忘了修改一下 $cut(x,y)$ 的部分，要先判完 $findroot(x)==findroot(y)$ 再 $split(x,y)$ ，否则树形会被修改。 模板的代码是修改过的了，魔法森林的就不改了（以作对比） 顺便献上发现原因 uoj274 [清华集训2016]温暖会指引我们前行修改前修改后（不要在意第 $20$ 个点的时间……） 写在前面最近一直在补之前欠了好久的锅，像后缀自动机啊什么的，总算轮到 LCT 了，感觉也挺对不起的，学了这么久的 OI 了现在才学会这个…… 但毕竟这个学习笔记主要还是给自己复习这个算法（老是忘）的时候看的，也就不讲的那么清楚了反正写这篇博客的时候我还是会的 概述LCT实际是实链剖分，就是只有一个其中儿子的边的实边，其他的都是虚边，但是因为虚实可以动态变化，所以要用 splay 维护。 每一棵 splay 维护的是一条实链的信息，构成一个 splay 森林（原来的其实也是一个森林）。其中满足：1、splay 按照深度为关键字对原树上节点排序，中序遍历 splay 树得到的是该实链的深度严格递增的排列。2、每个节点在且仅在一棵 splay 中3、父亲只认实儿子，儿子认父亲。（所以当一个点是它所在的实链的根的条件就是他的父亲没有他这个儿子） 因为原树是没有根的，所以本身也没有深度这一说，但是 LCT 中要指定一个根才行（然后就有了换根的操作） 可以资瓷：1、查询、修改链上的信息 （子树不行！！！）2、指定原树上一个点作为根（就是上面说的换根）3、连边、删边、动态维护连通性4、挖坑留给以后见到的神奇用法 操作$isroot(x)$判断 $x$ 是不是它所在实链的根 -&gt; $x$ 不是 $fa[x]$ 的任意一个儿子。 $access(x)$这个操作很重要所以要大一点打通 $x$ 到 $x$ 的路径为新的实链，即 $x$ 到 $x$ 的路径上的点维护在一棵 splay 中（没有图，所以只能感性理解） 方法： 1、将 $x$ splay 到所在实链的根，断开他的右子树 (深度比他大的点就不认了） 2、再看 $fa[x]$ 这个点，同样把它转到根，将刚刚的 $x$ 所在实链接在右子树上。 3、将 $x$ 变成 $fa[x]$，反复进行操作2直到 $fa[x]$ 不存在 12345inline void access(int x)&#123; for(int tmp=0;x;tmp=x,x=fa[x]) splay(x),son[x][1]=tmp,update(x);&#125; $makeroot(x)$将 $x$ 作为原树的根，会修改的就是 splay 上按照深度的遍历顺序，因为 $access(x)$ 后 $x$ 一定是所在实链上深度最大的点，当 $x$ splay 到根时，是不会有右子树的，直接 $reverse$ 左右子树就达到了反转序列的效果了。 所以要打一个 $rev$ 的 $tag$ （和系列的 $pushdown$ 操作） 12345inline void reverse(const int &amp;root) &#123;rev[root]^=1,swap(ls,rs);&#125;inline void makeroot(const int root) &#123; access(root),splay(root),reverse(root);&#125; 因为有了 $tag$ ，splay的时候就要注意 $pushdown$ 避免转错了。先将 $x$ 到 $root$ 的路径上点从上到小 $pushdown$ 完再 splay 吧。 $findroot(x)$找到 $x$ 所在原树上的根，用于判断连通性。方法：$access(x)$ 后 $x$ 所在 $splay$ 中深度最小的点（序列最左）的便是根了，再将 $x$ splay 到根，一路找左儿子便能找到根了。123456inline int findroot(int root)&#123; access(root),splay(root); while(ls) pushdown(ls),root=ls; return root;&#125; upd:某位神仙告诉我splay了就不用pushdown了（好像很有道理）OrzOrz $split(x,y)$因为经常要求的是两点之间路径的情况，光是一个点到根是不够的，所以就有了 $split(x,y)$ 用于将 $x$ 的 $y$ 路径上的点放在一个 splay 中方便查询。方法：将 $x$ 变成根以后，$access(y)$ 得到的便是 上述的 splay 了，此时再将 $y$ 转到根，便可以直接通过 $y$ 得到整个 splay （这条路径） 的所有信息了。1234inline void split(const int x,const int y)&#123; makeroot(x),access(y),splay(y);&#125; $link(x,y)$将 $x$ 变成根以后，将 $X$ 的父亲置成 $y$ 便是连边 $x$、$y$ 了。别忘了判断当前的 $y$ 是不是已经在 $x$ 所在的树中了。12345inline void link(const int x,const int y)&#123; makeroot(x); if(findroot(y)!=x) fa[x]=y;&#125; $cut(x,y)$如果保证存在边 $(x,y)$ 的话，$split(x,y)$ 后 $y$ 为根，$x$ 必为 $y$ 的左儿子（深度比 $y$ 小一），直接 $fa[x]=son[y][0]=0$断掉就行。 但是当不保证时需要满足:1&gt; $x$ 和 $y$ 在同一棵树中2&gt; $split(x,y)$ 后 $son[y][0]==x$3&gt; $split(x,y)$ 后 $x$ 没有右子树（因为 $x$ 的后继只应该是 $y$） 三个条件缺一不可 1234567inline void cut(const int x,const int y)&#123; split(x,y); if(findroot(x)!=findroot(y)||son[y][0]!=x||son[x][1]) return; fa[x]=son[y][0]=0; update(y);&#125; 若还有别的操作待补 例题一、luogu3690 [模板]Link Cut Tree(动态树)洛咕就是上面说的那些操作啦，splay 维护一下链 xor 和 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=3e5+10; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline void write(int x) &#123; int len=0;static int bask[50]; do bask[++len]=x%10,x/=10; while(x); for(;len;len--) putchar('0'+bask[len]); putchar('\n'); &#125; int val[N]; namespace LinkCutTree &#123; int son[N][2],fa[N],sum[N],rev[N]; #define ls son[root][0] #define rs son[root][1] inline int dir(const int &amp;root) &#123;return son[fa[root]][1]==root;&#125; inline bool isroot(const int &amp;root) &#123;return son[fa[root]][0]!=root&amp;&amp;son[fa[root]][1]!=root;&#125; inline void update(const int &amp;root) &#123;sum[root]=sum[ls]^sum[rs]^val[root];&#125; inline void reverse(const int &amp;root) &#123;rev[root]^=1,swap(ls,rs);&#125; inline void pushdown(const int &amp;root) &#123; if(rev[root]) return; if(ls) reverse(ls); if(rs) reverse(rs); rev[root]=1; &#125; inline void rotate(const int &amp;root) &#123; int f=fa[root],d=dir(root); if(!isroot(f)) son[fa[f]][dir(f)]=root; fa[root]=fa[f]; fa[son[root][d^1]]=f; son[f][d]=son[root][d^1]; son[root][d^1]=f,fa[f]=root; update(f),update(root); &#125; inline void splay(const int &amp;root) &#123; static int tot,list[N]; list[tot=1]=root; for(int x=root;!isroot(x);x=fa[x]) list[++tot]=fa[x]; for(int i=tot;i;i--) pushdown(list[i]); for(;!isroot(root);rotate(root)) if(!isroot(fa[root])) rotate(dir(fa[root])^dir(root)?root:fa[root]); &#125; inline void access(int root) &#123; for(int tmp=0;root;tmp=root,root=fa[root]) splay(root),son[root][1]=tmp,update(root); &#125; inline void makeroot(const int root) &#123; access(root),splay(root),reverse(root); &#125; inline void split(const int x,const int y) &#123; makeroot(x); access(y); splay(y); &#125; inline int findroot(int root) &#123; access(root),splay(root); while(ls) pushdown(ls),root=ls; splay(root); //保证复杂度！！！ return root; &#125; inline void link(const int x,const int y) &#123; makeroot(x); if(findroot(y)!=x) fa[x]=y; &#125; inline void cut(const int x,const int y) &#123; if(findroot(x)!=findroot(y)) return; split(x,y); if(son[y][0]!=x||son[x][1]) return; fa[x]=son[y][0]=0; update(y); &#125; &#125; void work() &#123; int n=read(),m=read(); for(int i=1;i&lt;=n;i++) val[i]=read(); using namespace LinkCutTree; while(m--) &#123; int op=read(),x=read(),y=read(); switch(op) &#123; case 0: split(x,y),write(sum[y]);break; case 1: link(x,y);break; case 2: cut(x,y);break; case 3: val[x]=y,splay(x); &#125; &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 后来都把 root 打成 x 了，四个字母看着好长 二、bzoj3669 [Noi2014]魔法森林洛咕2387 bzoj3669 先按照 $a$ 排序，然后对于边 $edge(u,v)$ 判断：当 $u$，$v$ 没有连通时，加上 $edge$；否则，找到连通 $u$，$v$ 的边中 $b$ 最大的边 $t$，如果 $b(t) &gt; b(edge)$，用 $edge$ 替换 $t$。（删掉 $t$ 加上 $edge$） 每次判断 $1$ 是否已经连通 $n$，若已连通，更新$ans=min(ans,a(edge)+1到n路径上b的最大值)$ 对于动态加边、删边、维护连通性和查询两点最大权值用 LCT 解决。 但是由于 LCT 只能存储点的信息（边不行），所以我们将一条边也看作一个点.若要加上边 $edge$，就相当于 $link(u,edge)$、$link(edge,v)$。 代码还是挺好写的，$cut$ 的时候写成了 $fa[y]=son[y][0]=0$ 调了好久……偷懒记了一些神奇的东西123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; const int N=1e5+10; const int inf=0x3f3f3f3f; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; struct edge &#123; int u,v,a,b; bool operator &lt; (const edge &amp;t) const &#123; return a&lt;t.a; &#125; &#125;e[100010]; namespace LinkCutTree &#123; int son[N][2],fa[N],val[N],rev[N],id[N],mx[N],idedge[N]; #define ls son[x][0] #define rs son[x][1] inline bool isroot(const int &amp;x) &#123;return son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x;&#125; inline int dir(const int &amp;x) &#123;return son[fa[x]][1]==x;&#125; inline void reverse(const int &amp;x) &#123;rev[x]^=1,swap(ls,rs);&#125; inline int Max(const int &amp;x,const int &amp;y) &#123;return val[x]&gt;val[y]?x:y;&#125; inline void update(const int &amp;x) &#123;mx[x]=Max(Max(mx[ls],mx[rs]),id[x]);&#125; inline void pushdown(const int &amp;x) &#123; if(!rev[x]) return; if(ls) reverse(ls); if(rs) reverse(rs); rev[x]=0; &#125; inline void rotate(const int &amp;x) &#123; int f=fa[x],d=dir(x); if(!isroot(f)) son[fa[f]][dir(f)]=x; fa[x]=fa[f]; son[f][d]=son[x][d^1]; fa[son[x][d^1]]=f; son[x][d^1]=f,fa[f]=x; update(f),update(x); &#125; inline void splay(const int &amp;x) &#123; static int tot,list[N]; list[tot=1]=x; for(int i=x;!isroot(i);i=fa[i]) list[++tot]=fa[i]; for(int i=tot;i;i--) pushdown(list[i]); for(;!isroot(x);rotate(x)) if(!isroot(fa[x])) rotate(dir(x)^dir(fa[x])?x:fa[x]); &#125; inline void access(int x) &#123; for(int t=0;x;t=x,x=fa[x]) splay(x),son[x][1]=t,update(x); &#125; inline void makeroot(const int &amp;x) &#123; access(x),splay(x),reverse(x); &#125; inline void split(const int &amp;x,const int &amp;y) &#123; makeroot(x),access(y),splay(y); &#125; inline int find(int x) &#123; access(x),splay(x); while(ls) pushdown(x),x=ls; return x; &#125; inline void link(const int &amp;x,const int &amp;y) &#123; makeroot(x); if(find(y)!=x) fa[x]=y; &#125; inline void cut(const int &amp;x,const int &amp;y) &#123; split(x,y); if(son[y][0]!=x||son[x][1]) return; fa[x]=son[y][0]=0; update(y); &#125; inline int query(const int &amp;x,const int &amp;y) &#123; split(x,y); return mx[y]; &#125; &#125; void work() &#123; int n=read(),m=read(),ans=inf; for(int i=1;i&lt;=m;i++) e[i]=(edge)&#123;read(),read(),read(),read()&#125;; sort(e+1,e+1+m); using namespace LinkCutTree; for(int i=1,tot=n;i&lt;=m;i++) &#123; int u=e[i].u,v=e[i].v,w=e[i].b; if(find(u)==find(v)) &#123; int ed=query(u,v); if(val[ed]&lt;=w) continue; cut(e[idedge[ed]].u,ed),cut(e[idedge[ed]].v,ed); val[ed]=w,idedge[ed]=i; link(u,ed),link(v,ed); &#125; else &#123; val[++tot]=w,id[tot]=tot; idedge[tot]=i; link(u,tot),link(v,tot); &#125; if(find(1)==find(n)) ans=min(ans,e[i].a+val[query(1,n)]); &#125; printf("%d\n",ans==inf?-1:ans); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125; 一粘代码就显得好长…… 参考资料FlashHu http://www.cnblogs.com/flashhu/p/8324551.htmlCandy? https://www.cnblogs.com/candy99/p/6271344.html]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2154 Crash的数字表格 [莫比乌斯反演]]]></title>
    <url>%2F2018%2F12%2F16%2Fbzoj2154%2F</url>
    <content type="text"><![CDATA[题意bzoj2154luogu1829 给定两个数 $n$，$m$（ $n，m \leqslant 1e7$ ），求 \sum_{i=1}^n \sum_{j=1}^m lcm(i,j)分析这篇题解是很早以前写的了，然后搬到了博客上……果然，人总要为一些很傻的事情付出代价，就像当时的我知道 markdown 怎么转成 PDF 后删掉 markdown 源码的一样。emmmmm……大力图片 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const int p=20101009,N=1e7+10; const int inv2=(p+1)/2; int n,m,cnt,mu[N],prime[N]; ll sum[N]; bool vis[N]; inline void init(int maxn) &#123; mu[1]=1; for(int i=2;i&lt;=maxn;i++) &#123; if(!vis[i]) prime[++cnt]=i,mu[i]=-1; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*prime[j])&lt;=maxn;j++) &#123; vis[k]=1; if(i%prime[j]==0) &#123;mu[k]=0;break;&#125; mu[k]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=maxn;i++) sum[i]=(sum[i-1]+1LL*i*i*mu[i]%p)%p; &#125; inline ll cal(ll x) &#123; return (1+x)*x%p*inv2%p; &#125; ll F(int x,int y) &#123; ll ans=0,limit=min(x,y); for(ll l=1,r;l&lt;=limit;l=r+1) &#123; r=min(x/(x/l),y/(y/l)); ans=(ans+cal(x/l)*cal(y/l)%p*(sum[r]-sum[l-1]+p)%p)%p; &#125; return ans; &#125; void work() &#123; scanf("%d%d",&amp;n,&amp;m); ll limit=min(n,m),ans=0; init(limit); for(ll d=1,last;d&lt;=limit;d=last+1) &#123; last=min(n/(n/d),m/(m/d)); ans=(ans+(d+last)*(last-d+1)%p*inv2%p*F(n/d,m/d)%p)%p; &#125; printf("%lld\n",(ans+p)%p); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4591 [SHOI2015]超能粒子炮·改 [数学]]]></title>
    <url>%2F2018%2F12%2F16%2Fbzoj4591%2F</url>
    <content type="text"><![CDATA[题目bzoj4591luogu4345 $t \ (t \leqslant 1e5)$ 组询问，每次给定两个数 $n、k \ (n、k \leqslant 1e18)$，求 \sum_{i=0}^k C_n^i \mod 2333分析emmmm……和bzoj2154那篇题解一样的命运 但是不知道为什么这个 PDF 显示的 $\LaTeX$ 这么粗 （ 好丑 ），勉强看一下 毕竟实在懒得再打了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;namespace TYC&#123; const int p=2333,N=2350; typedef long long ll; int C[N][N],f[N][N]; inline ll read() &#123; ll x=0;int f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline int Mod(int x) &#123;return x&gt;=p?x-p:x;&#125; inline void init() &#123; C[0][0]=1; for(int i=1;i&lt;p;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=i;j++) C[i][j]=Mod(C[i-1][j-1]+C[i-1][j]); &#125; for(int i=0;i&lt;p;i++) for(int j=0;j&lt;p;j++) f[i][j]=Mod(f[i][j-1]+C[i][j]); &#125; inline int Lucas(ll n,ll m) &#123; if(!m) return 1; if(n&lt;m) return 0; return C[n%p][m%p]*Lucas(n/p,m/p)%p; &#125; inline int F(ll n,ll k) &#123; if(!k||!k) return 1; if(n&lt;p&amp;&amp;k&lt;p) return f[n][k]; return Mod(f[n%p][p-1]*F(n/p,k/p-1)%p+Lucas(n/p,k/p)*f[n%p][k%p]%p); &#125; void work() &#123; init(); int T=read(); while(T--) &#123; ll n=read(),k=read(); printf("%d\n",F(n,k)); &#125; &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loj531「LibreOJ β Round 5」游戏 [基环树] [博弈]]]></title>
    <url>%2F2018%2F12%2F16%2Floj531%2F</url>
    <content type="text"><![CDATA[题面loj531.「LibreOJ β Round #5」游戏 题目描述LCR 发现，精确匹配是通过与随机对手（称为「神犇」）游戏的方式，藉由游戏的决策来评定智商的机制。游戏规则如下： 有一个长为 $n$，下标为 $[1,n]$, 的数组 $f[\ ]$，且满足 $f[i]\in [1,n]$。 有一个变量 $a$ 初始值为 $1$。双方轮流操作，LCR 先手。 操作方法：每次在所有满足 $f[i]=a$ 的 $i$ 中选一个，并将 $a$ 赋值为 $i$，不能不选。无法操作者输，若共 $2n$ 次操作后仍未决出胜负，则为平局。 我们定义二元关系“到达”如下： 1、$i$ 可以到达 $i$2、$i$ 可以到达 $f[i]$3、如果 $i$ 能到达 $j$，$j$ 能到达 $k$，则 $i$ 能到达 $k$。则 $f$ 数组满足性质：对于任意 $i$,$j$ 存在 $k$ 使得 $i$ 和 $j$ 都能到达 $k$。 LCR 即将面对 $q$ 局游戏。她发现每局游戏的 $f[]$ 数组都和给定的「模板数组」很像。经过进一步研究她发现每局游戏可以描述如下： 给出两个整数 $u$,$v$，满足在模板数组中 $f[u]$ 能到达 $u$，$f[v]$ 能到达 $v$。则该局游戏的 $f[]$ 是把模板数组的 $f[u]$ 赋值为 $v$ 后得到的。 现在 LCR 希望你帮她计算每局游戏的胜负状态。 输入格式第一行两个正整数 $n$,$q$。 第二行 $n$ 个整数表示 $f[]$。 接下来 $q$ 行每行两个整数 $u,v$ 描述一局游戏。 输出格式输出共 $q$ 行。 每行一个整数 $r$ 表示结果。 $r=1$ 表示先手（LCR）有必胜策略，$r=0$ 表示后手（神犇）有必胜策略，$r=2$ 表示平局。 样例输入7 33 1 2 3 4 3 21 12 32 1 样例输出200 分析这个题目怎么这么 $wqwqqwqwq$ …… 首先先看”到达”，其中 i 可以到达 f[i] 说明我们可以对于每一个 $i$ 建一条边 $i \ -&gt;f[i]$ ，然后就建成了一个 $n$ 个点 $n$ 条边的 基环内向森林 ，然后又因为 f数组满足性质：对于任意 i、j 存在 k 使得 i 和 j 都能到达 k，说明整个图是联通的，那么就得到了一棵 基环内向树 。 再分析询问中 满足 f[u] 能到达 u ，f[v] 能到达 v，原本就有边 $u \ -&gt;f[u]$，现在又得知存在有 $f[u]-&gt;u$，说明点 $u$、$f[u]$ 在基环上，点 $v$、$f[v]$ 同理。 题目理解完了，来一些博弈的简单前置技能 我们将一个状态（情况）看作一个点，从它向它能够一步转移（转移：变化成一个新状态）的状态连有向边，那么就有 一个状态如果能够转移到一个必败状态，那么它是必胜状态；如果它能转移到的全部是必胜状态，那么它是必败状态。 如果它两者皆不是（转移边构成了一个环），那么它是平局状态 考虑 $f[i]=x$ 意味着什么：当 $a=x$，$a$ 就会转移成 $i$ ，那么说明博弈的决策边应当为 $f[i]-&gt;i$ （变成基环外向树了），每次从点 $1$ 向沿决策边转移。 遇到基环外向树，果断先找环，我们从外向树向环上的点递推，就可以得到 $win[i] \in \{0,1\}$ 表示如果从点 $i$ 向外走，最后是否能够必胜。就可以得到所有状态的情况了。 我们记出度 $deg[ \ \ ]$，不断找没有出度的点，从 $i$ 走到 $f[i]$，并更新 $win[f[i]]$ 和$deg[f[i]]$ 即可，遍历过的点记 $deg[i]=-1$ 表示 $i$ 存在过出度减为 $0$ 的情况（即点 $i$ 不在环上，因为环上的点必然会有出度）。 当点 $1$ 不在环上时，它只存在唯一 一种决策，修改环上 $u$、$v$ 的连边对它没有影响，直接输出 $win[1]$ 即可。 否则点 $1$ 必然在环上，那么我们爬边 $i-&gt;f[i]$ 就可以遍历整个环，记下来。但是因为它与我们实际决策树的边相反，应当改成 $f[i]-&gt;i$ ，即要交换点 $id[i]-1$ $(f[x]==i 的点 x)$ 和 $id[i]+1 (f[i])$ ，再重新标号后就会有 $id[f[i]]+1==id[i]$ ，即边为 $f[i]-&gt;i$ （标号表现了它到点 $1$ 的距离）。 然后我们记 $near[i]$ 为距离点 $i$ 最近的必胜点 （不存在必胜点即为 $0$），在环上反着搜表示从点 $1$ 出发，即 12for (int i = num; i; i--) near[i] = (win[loop[i]] ? i : near[i + 1]); 现在如果我们要找 $l$ ~ $r$ 的链上找是否有必胜点时，直接查 $near[l]$ 即可 12345int query(int l, int r) &#123; if (l &gt; r) return 0; return near[l] &lt;= r ? near[l] : 0;&#125; 好，处理完了后我们来看询问。（心累累） 首先先把 $u$、$v$ 变成它在环上的标号 $id$ ，考虑：将 $f[u]=v$ 后原本边 $f[u]-&gt;u$ 就变成了 $v-&gt;u$ ，原本的边被断掉了。 分类讨论 一 、$u&gt;v$ 如图 从 $1$ 到 $v$ 存在有一个必胜点 $t$，则一定会走到这个点，直接输出 $t \&amp; 1$ 即为走到 $t$ 获胜的人。 不存在必胜点时，再判断： ​ 如果链 $v+1$ 到 $f[u] \ (u-1)$ 上存在有一个必胜点 $t$ 且与点 $v$ 的奇偶性相同，则走到 $v$ 的人一定会选择走这 条链走到点 $t$ 取胜；如果没有它可以一直走到 $f[u]$ 逼的对手无路可走，即点 $f[u]$ 的奇偶性与 $v$ 不同（即 $u$ 与 $v$ 的奇偶性相同），他也会走这条路 。最终结果都会使走到 $v$ 的人取胜。 123tmp = query(v + 1, u - 1); if ((tmp &amp;&amp; ((tmp &amp; 1) == (v &amp; 1))) || (!tmp &amp;&amp; ((u &amp; 1) == (v &amp; 1)))) printf("%d\n", v &amp; 1); 否则，走到 $v$ 的人就会选择走新边 $v-&gt;u$ 了（因为不走自己也赢不了），那么再判断： ​ 如果从 $u+1$ 到 $num$ 都没有必胜点，然后就相当于整个环上都没有必胜点了，平局；存在时，原本走到 $t$ 的人（$t\&amp;1$） 还要因为走了边 $v-&gt;u$ 改变奇偶性，即 (u &amp; 1) ^ (v &amp; 1) ^ (tmp &amp; 1) ^ 1。 二 、$u&lt;v$ 首先，当 $u \neq 1$ 时，如图 ​ 就只能从点 $1$ 走到 $f[u]$ 直接看这条路上有没有必胜点，没有就看谁走到了尽头点 $f[u]$ 当 $u = 1$ 时，相当于断开了 $fa[1]-&gt;1$ 的边，连上了 $v-&gt;1$ ​ 那么，如果 $1-&gt;v$ 上有必胜点，就直接到必胜点了，否则考虑：如果 $v-&gt;f[u]$ 上有必胜点，况且走到 $v$ 的人刚好走到这个必胜点，或者走到 $v$ 的人刚好走到 $f[u]（num）$ 使对方无路可走，那么他就就会选择走 $v-&gt;f[u]$ 的边取胜。 ​ 否则，他就只能走新边 $v-&gt;1$ ，但是 $1-&gt;v$ 上又没有必胜点，就变成了平局。 代码终于可以看代码了…… 代码风格又变了（突然开始打空格） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define _namespace TYC&#123; const int N = 1e6 + 10; int n, m, num, fa[N], deg[N], win[N], loop[N], id[N], near[N]; inline int read() &#123; int x = 0, f = 0; char ch = getchar(); while(!isdigit(ch)) f |= (ch == '-'), ch = getchar(); while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return f ? -x : x; &#125; void dfs(int u) &#123; deg[u] = -1; if (win[u] == 0) win[fa[u]] = 1; deg[fa[u]]--; if (!deg[fa[u]]) dfs(fa[u]); &#125; int query(int l, int r) &#123; if (l &gt; r) return 0; return (near[l] &lt;= r ? near[l] : 0); &#125; void work() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) deg[fa[i] = read()]++; for (int i = 1; i &lt;= n; i++) if (!deg[i]) dfs(i); if (deg[1] == -1) &#123; while (m--) printf("%d\n", win[1]); return; &#125; for (int now = 1; !num || now != 1; now = fa[now]) loop[++num] = now; for (int i = 2; i &lt;= num - i + 2; i++) swap(loop[i], loop[num - i + 2]); for (int i = 1; i &lt;= num; i++) id[loop[i]] = i; for (int i = num; i; i--) near[i] = (win[loop[i]] ? i : near[i + 1]); while (m--) &#123; int u = read(), v = read(); u = id[u], v = id[v]; if (u &gt; v) &#123; int tmp = query(1, v); if (tmp) printf("%d\n", tmp &amp; 1); else &#123; tmp = query(v + 1, u - 1); if ((tmp &amp;&amp; ((tmp &amp; 1) == (v &amp; 1))) || (!tmp &amp;&amp; ((u &amp; 1) == (v &amp; 1)))) printf("%d\n", v &amp; 1); else &#123; tmp = query(u, num); if (!tmp) printf("2\n"); else printf("%d\n", (u &amp; 1) ^ (v &amp; 1) ^ (tmp &amp; 1) ^ 1); &#125; &#125; &#125; else &#123; if (u != 1) &#123; int tmp = query(1, u - 1); if (!tmp) printf("%d\n", u &amp; 1); else printf("%d\n", tmp &amp; 1); &#125; else &#123; int tmp = query(1, v); if (tmp) printf("%d\n", tmp &amp; 1); else &#123; tmp = query(v + 1, num); if((tmp &amp;&amp; (tmp &amp; 1) == (v &amp; 1)) || (!tmp &amp;&amp; (num &amp; 1) != (v &amp; 1))) printf("%d\n", v &amp; 1); else printf("2\n"); &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; TYC::work(); return (0^_^0);&#125; 最后快膜LCA]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>基环树</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3157/3516 国王奇遇记 [数学]]]></title>
    <url>%2F2018%2F12%2F16%2Fbzoj3157%263516%2F</url>
    <content type="text"><![CDATA[题意 \sum_{i=0}^n i ^ m \times m ^ i其中 $1 \leqslant n \leqslant 10^9$ ， $1 \leqslant m \leqslant N$ ，其中的 $N$ 是因为这个题有三个版本 \begin{align*} &bzoj3157 - N \leqslant 200 \\ &bzoj3516 - N \leqslant 1000 \\ &b bzoj4126 - N \leqslant 500000 \\ \end{align*}但我只会 $O(m^2)$ 的，所以先不提第三题（挖坑待填） 分析发现 $n$ 很大，不能直接枚举 $i$ ，考虑从 $m$ 入手 递推 记 $f_{n,a} = \sum_{i=0}^n i^a m^i$ （这里 $i$ 从 $0$ 开始方便后面转换，$i =0$ 对答案没有影响），题目要求 $f_{n,m}$ ，考虑转移 \begin{align*} f_{n,a} &= \sum_{i=0}^n i^a m^i \\ &= m \sum_{i=0}^n i^a m^{i-1} \ \ \ //提出一个m \\ &= m \sum_{i=0}^{n-1} (i+1)^a m^i \ \ \ //用 \ i \ 表示 \ i+1 \\ \end{align*}当 $i = -1$ 时 $(i+1)^a =0$ 大力不理 再根据二项式定理 $(a+b)^n = \sum_{i=0}^n C_n^i a^i b^{n-i}$ \begin{align*} &= m \sum_{i=0}^{n-1} m^i \ \sum_{k=0}^a C_a^k i^k \\ &= m \sum_{k=0}^a C_a^k \ \sum_{i=0}^{n-1} i^k m^i //交换枚举顺序 \\ &= m \sum_{k=0}^a C_a^k \ f_{n-1,k} \\ &= m \sum_{k=0}^a C_a^k \ (f_{n,k} - n^k m^n) \end{align*}得到了$O(m^2)$ 的转移方程，完结撒花 好像 $O(m)$ 的要多项式插值和快速傅里叶变换求解，不会，不想填坑了 等等！完结不了，注意： 1、上式的 $k$ 有取到 $a$ 的情况，解个关于 $f_{n,i}$ 方程就好了 2、$f[0] = \sum_{i=0}^n m^i$ 等比数列，先一算，特判 $m=1$ 时不能用等比数列求和公式，直接 $ans = \sum_{i=1}^n i = \frac{n \times (n+1)}{2}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;namespace TYC&#123; typedef long long ll; const ll p=1e9+7; const int N=1010; int n,m; ll f[N],Pow[N],C[N][N]; inline ll qpow(ll x,ll tim) &#123; ll ans=1; for(;tim;tim&gt;&gt;=1,x=x*x%p) if(tim&amp;1) ans=ans*x%p; return ans; &#125; #define Mod(x) (x)&gt;=p?(x)-p:(x) void init() &#123; C[0][0]=1; for(int i=1;i&lt;=m;i++) &#123; C[i][0]=1; for(int j=1;j&lt;=m;j++) C[i][j]=Mod(C[i-1][j-1]+C[i-1][j]); &#125; Pow[0]=1; for(int i=1;i&lt;=m;i++) Pow[i]=Pow[i-1]*n%p; &#125; void work() &#123; scanf("%d%d",&amp;n,&amp;m); if(m==1) &#123; printf("%lld\n",(ll)(n+1)*n/2%p); return; &#125; init(); ll t1=qpow(m,n),t2=t1*m%p,inv=qpow(m-1,p-2); f[0]=(Mod(qpow(m,n+1)-1+p))*qpow(m-1,p-2)%p; for(int i=1;i&lt;=m;i++) &#123; ll sum=0; for(int j=0;j&lt;i;j++) sum=Mod(sum+(C[i][j]*(f[j]-Pow[j]*t1%p+p)%p)); if(m!=1) f[i]=(Pow[i]*t2-m*sum+p)%p*inv%p; &#125; printf("%lld\n",f[m]); &#125;&#125;int main()&#123; TYC::work(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错位排列 学习笔记 [数学]]]></title>
    <url>%2F2018%2F12%2F16%2F%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[写在前面那就先从一个例题引入吧 （来自《组合数学》P110） 题目在一次聚会上，有 $n$ 位男士和 $n$ 位女士。这 $n$ 位女士能够有多少种方法选择男舞伴开始第一支舞？如果在一首曲后每个人必须换舞伴，那么第二支舞又有多少种选择方法？ 分析首先，第一支舞有 $n!$ 中选择，而第二支舞的选择方法数为后面要讲的错位排列数 $D_n$ （说起来这个例子好像我校神犇兔崽子 Tzz 换女朋友） 错位排列首先安利 $Planet6174$ 的博客讲解 小学生都能看懂的错排问题解析 （高中生表示看懂了） 问题给定 $n$ 元集合 $X$，它的每一个元素都有一个特定的位置，而现在要求求出没有一个元素在它指定的位置上的排列的数目。（发现就是上面的第二支舞） 特别的，请注意，每一个元素都只有一个限定不能放的位置。 方法我们这里假定第 $i$ 个元素不能放在第 $i$ 个位置上（因为不一样的我们可以通过交换达成，对应顺序没有影响） 用 $D_n$ 表示 $\{1,2,3,…n\}$ 的错位排列的数目。那么，对于 $n=1$ ，不存在可行解； $n=2$ 时，唯一的错位排列是 2 1； $n=3$ 时有两个排列 2 3 1 和 3 1 2。因此，我们有 $D_1=0$， $D_2=1$， $D_3=2$。 递推式考虑将第 $n$ 个元素放到第 $k$ 个位置 $(k \neq n)$，有 $n-1$ 种放法，然后分类讨论 1、第 $k$ 个元素放到了第 $n$ 个位置上发现这样的话第 $n$ 个和第 $k$ 个就相当于不存在了，不影响其他元素的放置，此时，我们将其余的元素错位排列的方案数量有 $D_{n-2}$ 种 1、第 $k$ 个元素没有放到第 $n$ 个位置上这样相当于是加了一个限定：第 $k$ 个元素不能放在第 $n$ 个位置上。因为 $k$ 个位置已经被用过了，相当于不存在，那么可以说去掉了 $k$ 不放 $k$ 位的限制。这样我们可以交换第 $k$ 个和第 $n$ 个位置，就变成去掉了一个元素 $n$ 和位置 $k$ 的情况，即变成 $n-1$ 个元素的错位排列 $D_{n-1}$ 我们有了一个很简单的递推式 D_n = (n-1) \times (D_{n-2}+D_{n-1}) \ \ \ \ \ (n \geqslant 3)其中 $D_1 = 0$， $D_2 = 1$。 upd in someday in May 2019 哦，实在是不好意思，还有一个更简单的没有说。 把上面那个公式移项得到 D_n - nD_{n - 1} = -[D_{n - 1} - (n - 1)D_{n - 2}]因此，我们可以递归得到: \begin{aligned} D_n - nD_{n - 1} &= -[D_{n - 1} - (n - 1)D_{n - 2}] \\ &= (-1)^2 [D_{n - 2} - (n - 2)D_{n - 3}] \\ &= (-1)^3 [D_{n - 3} - (n - 3)D_{n - 4}] \\ &= \cdots \\ &= (-1)^{n - 2} [D_2 - 2 D_1] \end{aligned}因为 $D_1 = 0$，$D_2 = 1$，我们得到了错位排列更简单的递推关系 D_n = n D_{n - 1} + (-1)^{n - 2}等价于 D_n = n D_{n - 1} + (-1)^n(不用开数组了) 通项公式D_n = n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} \cdots + (-1)^n \frac{1}{n!} \right)证明这个……详见《组合数学》P108 简单推一下，主要思想 容斥原理 首先，不考虑限制，总排列数为 $n!$ 。减掉不合法的：至少有一个元素放到它的指定位置的有 $C_n^1$ 种，限定了这个个的放法后，其余的 $n-1$ 个元素可以随意排列，共有 $C_n^1 \times (n-1)!$ 种。但这样有算重的，还要加上两个元素都放在它的指定位置上的方案数 $C_n^2 \times (n-2)!$ 种，再减去三个元素的……就得到了 \begin{aligned} D_n &= n! - C_n^1 (n-1)! + C_n^2 (n-2)! \cdots (-1)^n C_n^n (n-n)! \\ &= n! - \frac{n!}{1!(n-1)!} \times (n-1)! + \cdots + (-1)^n\frac{n!}{n!(n-n)!} \times (n-n)! \\ &= n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} \cdots + (-1)^n \frac{1}{n!} \right) \\ \end{aligned}当然也可以 D_n = \sum_{i=0}^n (-1)^n C_n^i (n-i)!参考资料1、$Planet6174$ 小学生都能看懂的错排问题解析2、《组合数学》第六章 容斥原理及应用-错位排列 完结撒花 你以为这就完了？不不不，上面那些并不是导致我写这篇博客的根本原因，源自一道题 限制了一些元素放置位置的错位排列题目Codeforces 340E 问题描述给你 $n$ 个球 $n$ 个盒子，一个盒子只能放一个球,限定第 $i$ 个球不能放在第 $i$ 个位置上，但已知一些盒子里面已经放了球，求一共有多少种合法的放置方案。 输入格式第一行一个整数表示 $n$ 。第二行 $n$ 个数 $a_i$ 。如果 $a_i = -1$ 表示第 $i$ 个盒子没有放球，否则表示第 $i$ 个盒子已经放了球 $a_i$ 。 输出格式一个非负整数表示合法的方案数，模 $1e9+7$ 。 样例输入125 -1 -1 2 1 -1 样例输出14 数据范围 \begin{aligned} &10\% \ \ \ 1 \leqslant n \leqslant 10 \\ &50\% \ \ \ 1 \leqslant n \leqslant 2000 \\ &100\% \ \ \ 1 \leqslant n \leqslant 2000000 \\ \end{aligned}分析真是，第一眼看到这个题目就想到了错排，但当时这是一个甚至没有列入学习计划的东西却认出来了，然后当场去学，发现错排好简单……再然后，被告知这个题还有放球的限制…… 突破口就是将球分成两部分：一个是没有限制可以随便放的，一个是有限制球 $i$ 不能放在盒子 $i$ 的 。其中已经放好了的球就不管了。 然后就有了一个 $O(n^2)$ 的 $dp$ ，记 $f[i][j]$ 为剩余 $i$ 个没限制的球和 $j$ 个有限制的球的方案数，然后你大力转移一下，就有了一个 $50$ 分的好成绩，再次完结撒花。 没有转移方程 -&gt; 因为在推 $dp$ 式敲代码的时候看了一眼原本的错位排列后突然想到了 $O(n)$ 的…… 容斥！ 不要管没有限制的球，我们记 $tot$ 为没有放好的球的个数，记 $a$ 为有限制的球的个数 。不理限制时，总共有 $tot \ !$ 种，然后再像上面一样，枚举至少有一个球 $i$ 放到盒子 $i$ ，其余随便排的 $C_a^i \times (tot-i)!$ 种减掉，再加上至少两个的……最后 \begin{aligned} ans &= tot! - C_a^1 (tot-1)! + C_a^2 (tot-2)! + \cdots + (-1)^a C_a^a (tot-a)! \\ &= \sum_{i=0}^a (-1)^i C_a^i(tot-i)! \end{aligned}其实很简单（推式子用了一分钟，前面的一堆算上和机房的那群人聊天用了2h+—），好菜好菜…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define _ 0namespace TYC&#123; typedef long long ll; const int N=2e6+10; const int p=1000000007; const int inf=0x3f3f3f3f; int arr[N],vis[N]; ll fac[N],inv[N]; inline int read() &#123; int x=0,f=0;char ch=getchar(); while(!isdigit(ch)) f|=(ch=='-'),ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0',ch=getchar(); return f?-x:x; &#125; inline ll qpow(ll x,ll tim) &#123; ll ans=1; for(;tim;tim&gt;&gt;=1,x=x*x%p) if(tim&amp;1) ans=ans*x%p; return ans; &#125; void init(const int n) &#123; fac[0]=1; for(int i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%p; inv[n]=qpow(fac[n],p-2); for(int i=n;i;i--) inv[i-1]=inv[i]*i%p; &#125; inline ll C(const int n,const int m) &#123; if(n&lt;m) return 0; return fac[n]*inv[m]%p*inv[n-m]%p; &#125; inline void work() &#123; int n=read(); int tot=0,x=0; for(int i=1;i&lt;=n;i++) &#123; arr[i]=read(); if(~arr[i]) vis[arr[i]]=1; else tot++; &#125; for(int i=1;i&lt;=n;i++) if(!vis[i]) x+=(arr[i]==-1); init(tot); ll ans=0; for(int i=0;i&lt;=x;i++) ans=(ans+(((i&amp;1)?-1:1)*C(x,i)+p)%p*fac[tot-i]%p)%p; printf("%lld\n",ans); &#125;&#125;int main()&#123; TYC::work(); return (0^_^0);&#125;]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
